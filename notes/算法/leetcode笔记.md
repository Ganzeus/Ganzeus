## 笔记

#### Counter（python中的hashmap）

> 类似c++ std的map

```python
from collections import Counter

# 用法1: 统计列表/字符串元素出现次数（直接传入括号）
lst = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple']
counter = Counter(lst)		# 一个map, 统计元素出现次数
print(counter)	# Counter({'apple': 3, 'banana': 2, 'orange': 1})

s = "hello world"
counter = Counter(s)
print(counter)	# Counter({'l': 3, 'o': 2, 'h': 1, 'e': 1, ' ': 1, 'w': 1, 'r': 1, 'd': 1})

# 用法2：单独添加元素并计数
counter = Counter()
counter['l'] += 2	# 可以单独添加字符
counter['l'] -= 1	# 可以增减计数

# 用法3: 使用 .most_common(n) 获取出现频率最高的 n 个元素
counter = Counter("abracadabra")
print(counter.most_common(2))	# [('a', 5), ('b', 2)]

# 用法4：与普通字典一样访问元素计数
counter = Counter(['a', 'b', 'a', 'c'])
print(counter['a'])  # 输出 2
print(counter['z'])  # 输出 0（不存在的键默认是0）

# 用法5：Counter 的运算操作
c1 = Counter('abca')
c2 = Counter('acdd')

print(c1 + c2)   # 合并计数
print(c1 - c2)   # 相减（只保留正数）
print(c1 & c2)   # 交集：取 min
print(c1 | c2)   # 并集：取 max

"""
输出：
Counter({'a': 3, 'c': 2, 'b': 1, 'd': 2})
Counter({'b': 1})
Counter({'a': 1, 'c': 1})
Counter({'a': 2, 'c': 1, 'b': 1, 'd': 2})
"""
```





## 模板



### 二分查找

```python
# 在递增序列nums的[left，right]区间进行二分，找x返回下标，找不到返回-1
def binarySearch(nums, left, right, target):
    while(left <= right):		# 条件不成立说明找不到
        mid = left + (right-left) // 2
        if nums[mid] < target:		# 中点在目标值左边，往右找（[]
            left = mid + 1
        elif nums[mid] > target:		# 中点在目标值右边，往左找
            right = mid - 1
        else return mid
   	return -1		# 找不到返回-1

def lowerBound(nums, target):	# 返回>=k的最小下标
	l = 0, r = len(nums) - 1
    while(l < r):		# 退出循环时l=r说明已经找到
        mid = l + (r-l) // 2
        if mid < target:	# 中点<目标值时，答案一定在右边
            l = mid + 1
        else r = mid		# 中点大于或等于目标值时，答案要么是此处，要么在左边
    return l

def upperBound(nums, target):	# 返回>k的最小下标
    l = 0, r = len(nums) - 1
    while(l < r):		# 退出循环时l=r说明已经找到
        mid = l + (r-l) // 2
        if mid <= target:	# 中点<=目标值时，答案一定在右边
            l = mid + 1
        else r = mid		# 中点大于目标值时，答案要么是此处，要么在左边
    return l
```



```C++
//在递增序列a的[left，right]区间进行二分，找x返回下标，找不到返回-1
int binarySearch(int a[], int left, int right, int x) {
    while(left <= right) {      // 条件不成立说明找不到
        int mid = left + (right-left)/2;    // 取中点
        if(a[mid] == x) return mid;       // 找到，返回下标
        else if(a[mid] > x) right = mid-1;  // 中点值在要找的数右边，往左[left, mid-1]找
        else left = mid + 1;    // 往右[mid+1, right]找
    }
    return -1;
}


int lowerBound(vector<int>& a, int k) { // 大于等于k的最小下标
    int l = 0, r = a.size() - 1;
    while(l < r) {
        int mid = l + (r-l)/2;
        if(a[mid] >= k) r = mid;    // 中点大于等于k，可能就是此处，往左找
        else l = mid + 1;
    }
    return l;   // l==r说明找到
}

int upperBound(vector<int>& a, int k) { // 大于k的最小下标
    int l = 0, r = a.size() - 1;
    while(l < r) {
        int mid = l + (r-l)/2;
        if(a[mid] <= k) l = mid + 1;    // 中点小于等于k，往右找
        else r = mid;   // 中点大于k，可能就是此处
    }
    return l;
}
```



### 二叉树层序遍历（BFS)

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

        
def levelOrder(self, root: Optional[TreeNode]) ->List[List[int]];	# 传入根节点，返回一个列表，列表每个元素是每层的所有结点组成的子列表
	if root = None: 
        return []
    ans = []
    q = deque([root])		# deque是python中的双向队列
    while(q):
        vals = []		# 存放当前层的所有结点
        for _ in range(len(q)):		# 遍历次数为当前层的节点个数
            node = q.popleft()
            vals.append(node.val)
            if node.left: q.append(node.left)
            if node.right: q.append(node.right)
        ans.append(vals)
	return ans
            
```



## 一刷

#### 209.长度最小的子数组

思考

+ 先判断没有答案的情况：计算sum, <target返回0
+ 枚举子数组长度（1~n), 轮流计算
+ $时间O(n^2), 空间O(1)$
+ 改为二分子数组长度，空间复杂度为$O(n\sqrt n)$



灵神

+ 枚举右端点，收缩左端点
  + 右端点0~n-1,左端点从0开始，都只会一直右移，不会回头，因此共享$O(n)$复杂度——**滑动窗口**
  + 设置一个变量(s)作为当前的总和，而不是每次都从左加到右（右端点右移时s加上右端点元素值，左端点右移时s减去左端点元素值）
  + 右移右端点，直到总和>=target,记录答案，然后开始不断右移左端点，直到总和<target，接着枚举下一个右端点。
+ 时间：$O(n)$
  空间：$O(1)$
+ 为什么左端点只会右移不会回头？
  因为数组元素都为正，如果当前总和大于target，右端点右移后总和一定大于target，因此左端点一定会右移



#### 713.乘积小于K的子数组

思考

+ 暴力：两个for循环枚举所有子数组，每次都计算乘积并判断
+ 双指针：不会

灵神

+ 同向双指针（滑动窗口），设置变量记录当前的累乘
+ 先右移右指针，若当前[l,r]累乘<k，则添加答案:
  [l, r], [l+1, r], ..., [r, r]\(即[r])。（**这些子数组的个数为r-l+1**)
  若当前累乘>=k, 停止移动右指针，开始移动左指针
+ 移动左指针直到[l,r]累乘<k，添加答案后立刻继续移动右指针
+ 要点：**每次添加答案要严格保持右端点不变，这样才不会重复**
+ 时间：$O(n)$
  空间：$O(1)$



#### 3.无重复字符的最长子串

思考

+ 不会判断子串有没有重复字符（c++可以用map，但python不会)
+ 右移右指针，直到发现有重复字符，此时更新答案，并移动左指针直到没有重复字符为止

灵神

+ 方法一样
+ **python判断字符串重复字符————Counter类**
  + 只需要每次记录右端点元素的出现次数（因为重复元素必定是右端点）
+ 时间：$O(n)$
  空间：$O(128)$(字符的所有可能)



#### 162.寻找峰值

思考：

题目要求O(logn)，只能用二分，但是数组不是有序的，该如何判断往左还是往右？没思路

灵神：

红蓝染色法（红表示小，蓝表示大）->**即定义新的大小判定，把无序数组当成有序数组来看**

> 注意二分之前并不知道哪些元素是红，哪些是蓝，染色是在二分查找过程中进行的——即每次查找的区间为未染色的区间

+ 假设要找的**目标元素是某一个峰值（不能确定找的是哪一个，但一定能找到一个）**，定义红色为目标元素左边的元素，蓝色为目标元素或目标右边的元素
+ 只需要比较mid元素和其右边的大小，就可以判断目标峰值在左边还是右边：
  + 对于mid，若右边的元素(mid+1)更大，则**右边一定有峰值！极端情况是右边是递增序列，那么峰值就是最后一个元素**，即mid是某一个峰值的左侧，可以直接往右找，排除左边所有元素（即使左边也有峰值）；
  + 若右边的元素更小，则**左边一定有峰值！极端情况是左边是递减序列，那么峰值就是第一个元素**，即mid要么是峰值，要么在峰值右边，可以直接往左找，排除右边所有元素（即使右边也有峰值）
+ 数组最右边(n-1)一定是蓝色（若nums[n-2] > nums[n-1], n-1就是峰值右边；反之n-1就是峰值）



#### 206.反转链表

> 反转整个链表

思考：
遍历一次记录所有数值，接着重新创建链表（时空都是O(n))

灵神:

+ 原地修改链表——**三个指针pre, cur(当前结点）, next(防止丢失下一个结点)**

+ 每次将cur->next改为pre, 接着pre=cur, cur=next, next=next->next

+ 直到cur=null结束
+ 时间O(n), 空间O(1)



#### 92.反转链表II

> 反转中间部分链表

思考：
保存反转部分的前一个结点，反转结束后将这个结点的next改为已反转部分的第一个结点



灵神：

+ 特殊情况：反转部分没有前一个结点
+ 可以添加一个空结点dummy作为前一个结点
+ 反转链表的循环次数为right-left+1次



#### 25.K个一组翻转链表

> 每k个结点反转一次

思考：
反转n/k次

灵神：

+ 每段反转要修改p0为上一段的第一个结点
+ 不需要计算反转的段数，只需要每次反转判断剩余结点是否>=k



#### 876.链表中间结点

思考：

快慢指针,每次慢的移动一格，快的移动两格，快指针==n或null时结束，等于n是返回slow->next，等于null时返回slow

灵神

+ 不需要链表长度，只需要每次保证快指针的next不为空，就能继续移动
+ 若快指针的next为空，即可说明快指针==n



#### 142.环形链表II

> 判断链表是否有环,输出环的起点

思考：

快慢指针不停移动，指针相同时说明有环 
（如果有环快慢指针一定会相遇）

快指针为null时说明无环

如何找到环的入口？

灵神：

+ 慢指针从相遇点开始，和head指针同步走，一定会相遇，相遇点就是环入口
+ a(入口与head距离) = 若干倍环长 + c(快慢相遇点到入口的距离)



#### 143.重排链表

> 改为0->n->1->n-1->2->...

思考：
只会重建链表，不会原地修改

灵神：

+ 将中点到末尾的链表反转，接着把两个链表合并



#### 237.删除链表中的节点

> 只知道要删除的节点，不知道上一个节点

思考：

不知道前一个结点怎么删除？无法修改前一个节点的next

灵神：

+ 脑筋急转弯
+ **删除下一个节点，保留当前结点**（要先把下一个结点的数值复制到当前节点）



#### 19.删除链表的倒数第N个结点

思考：
双指针，左右指针相差n步，右指针走到头时，删除左指针

灵神：

+ 需要一个dummy node作为头节点，防止删除第一个结点的情况

#### 83.删除排序链表中的重复元素

> 已排序的链表去重

思考：
每个结点判断下一个结点元素值是不是和当前相等，相等就删掉



#### 82.删除排序链表中的重复元素II

> 删除全部重复元素，一个都不保留

思考：
下个结点值与当前相等时，记录当前结点，去重之后再删掉这个结点

灵神：

+ 需要创建dummy node，作为初始当前结点（当前节点一定时不重复的结点）
+ 判断next和next->next是否相同，相同就不断循环删除





100.相同的树

> 判断两个树是否相同

思考：

+ 层序遍历转成数组后直接判断(带null)
+ 同时dfs，只要不同就跳出



灵神：

+ 递归思想，转为子问题：
  + 根节点相同
  + 递归判断左子树相同
  + 递归判断右子树相同

+ 递归边界：有一个为空时返回false，两个都为空时返回true

101.对称二叉树

> 判断二叉树是否轴对称

思考

+ 相当于判断根节点的左右子树是否对称

灵神

+ 对称的判定：对于每个节点，左子树==右子树



110.平衡二叉树

> 判断每个结点左右子树高度差<=1

思考：

+ 递归判断
+ 先计算当前结点高度，再比较左右子树的高度差



#### 199.二叉树的右视图

思考

+ 层序遍历，保存每层的最后一个结点即可

灵神：

+ dfs，传入结点当前深度
+ 优先递归右子树，每层碰到的第一个结点就是本层最右边的结点



#### 98.验证二叉搜索树

> 判断BST

思考：

+ 前序遍历，得到严格递增序列就是BST
+ dfs, 返回子树的最大值，每个结点判断左子树最大值比当前小，右子树最大值比当前大

灵神：

1. 第一种：前序遍历，传入当前结点取值范围，满足取值范围即可
2. 第二种：前序遍历判断严格递增序列
   + 不需要遍历完后保存数组
   + 只需要一个pre变量，保存上一次访问的结点
3. 第三种：dfs，但**必须同时返回子树的最大和最小值**



#### 236.二叉树的最近公共祖先

思考：

+ 先dfs得到每个结点的父亲和每个结点的层数
+ 接着看成链表题，双指针，层数更深的结点先移动，直到层数相同时，一起移动，直到找到相同的father

灵神：

+ dfs过程中找p和q（传入p和q），返回找到的结点（p或q或None），左右子树依次递归
+ 分类讨论dfs的当前节点：
  1. p和q分别在左右两个子树中，那当前结点就是最近公共祖先
  2. 左右子树只有一边找到（即p和q在同一边），那么先遍历到谁，谁就是答案



#### 235.二叉搜索树的最近公共祖先

思考：

+ BST左小右大的性质怎么用？

灵神：

+ 已知p和q的值，只需要将p和q与dfs当前结点值比大小，
  就能知道p和q在左子树还是右子树中，不需要递归查找pq
  + p和q在左右两边，那当前结点就是答案
  + p和q在同一边，只需要递归那一边，继续判断大小即可，先遍历到的就是答案（即当前节点为p或q时返回）



#### 103.二叉树的锯齿形层序遍历

> 每层先左->右，再右->左

灵神：

+ 只需要设置一个bool变量，层序遍历时每层反转一下
+ bool变量反转时，当前层的结点数组也要翻转后加入答案（python可以直接用切片）









## 二刷

