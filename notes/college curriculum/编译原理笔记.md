编译原理笔记by以禾

****

## 第二章 文法和语言

### 一、描述语言的工具

#### 字母表与符号

##### 字母表

+ 非空的有穷集合
+ 用$V或\sum$表示
+ 如$V=\{a, b, ..., z\}, \sum=\{+,*,1, 2, ..., 9, 0, (, )\}$等
+ 符号或符号串

##### 符号

+ 最基本、不可分的单位
+ 不具备语法意义（**与单词作区分**）

##### 符号串

+ 字母表上的符号组成的有穷序列
+ 用$\alpha,\beta,\gamma...表示$
+ **空串：$\epsilon$**

##### 句子和语言

+ 句子：字母表上元素按照某种规则组成的串的集合
+ 语言：字母表上**句子的集合**，用L表示

+ 句子集合：A={a=b,if a then b, ...}

#### 符号串集合的运算

##### 连接（乘积）

+ 顺序很重要，$\alpha\beta \ne \beta\alpha$
+ 集合的乘积即相应每个元素的互相排列组合（**区分顺序**）

##### 方幂（次方）

+ 与自身的乘积
+ $对于集合A,A^0={\epsilon},A^1=A,A^2=AA,...$

##### 闭包（closure）

+ 某字母表可生成的所有符号串的集合
+ **集合中任意个元素的任意运算结果都在集合内（运算封闭）**
+ 用$A^*或closure(A)$表示
+ **$A^*=A^0 \cup A^1 \cup A^2 \cup ...$**

##### 正闭包（positive closure)

+ 闭包减去空串
+ 用$A^+$表示
+ $A^+ = A^1\cup A^2 \cup ... = A^*-\{\epsilon\}$

> 语言是**字母表上正闭包的真子集**

+ 任何一个程序（字符串）时字母表上闭包里的一个元素（**任意长度的字符串都在字母表闭包里**）



### 二、文法概念

>  文法（或语法grammar)是描述语言的形式规则
>
> 采用**形式语言**的方式表示文法
>
> + 用数字或公式定义语言

#### 标识符文法 = （非终结符，终结符，产生式，开始符号）

##### 产生式(Productions)

+ 又称规则、重写规则、生成式
+ 定义了符号串之间关系的一组语法规则
+ 采用BNF(**Backus-Naur Form**)等形式，如：$A\rarr \alpha$,读作**A产生$\alpha$**，或A定义$\alpha$
  + **左部或右部只能有一个字母**
  + 箭头可用:=或::=表示
+ 产生式的集合一般用P表示

##### 开始符号（start symbol）

+ 又称识别符
+ 第一个产生式左侧的非终止符
+ 用S表示

##### 非终结符（non-terminals)

+ 出现在产生式箭头左侧的符号（也可以在右边）
+ 用<...>表示一种语法概念，或**大写字母A、B...**
+ **用$V_N$表示非终结符集合**

##### 终结符（terminals）

+ 语言中不可再分割的符号串
+ j产生式箭头**右侧的小写字母、符号、单词**的集合
+ **用$V_T$表示终结符集合**



##### 文法的形式定义

+ 文法$G={V_N,V_T,P,S},其中V_N=\{A,B,...\},V_T=\{a,b,...,+,*,...\}$

  P由下列产生式组成：

  1. $S\rarr...$
  2. ...

+ **可缩写为：**（只要知道了开始符合产生式就能知道终结符和非终结符）

  G[S]：

  1. $S\rarr...$
  2. 



#### 推导与规约

##### 推导(derive)

+ 由开始符号起，通过**替换掉非终结符**，最终得到由终结符组成的**字符串**的过程
+ 规范推导：最左推导或最右推导（只替换左或右）

+ 推导符号：
  + **直接推导**：$\Rarr$
  + **一步以上推导**：$\Rarr^+$
  + **零步以上推导**：$\Rarr^*$

##### 规约(reduce)

+ 推导的逆过程
+ 由字符串开始，反推回开始符号
+ 规范规约，符号同推导



#### 句型、句子、语言时

##### (规范)句型：(规范)推导的中间结果

+ 从开始符号起，包括零步在内，每一步推导得到的符号串

##### 句子：仅含终结符的句型

+ 推导的最终结果

##### 语言：所有句子的集合

+ 推导出的句子的集合





#### 文法的类型

##### 文法$G=(V_N,V_T,P,S)$

##### Chomsky通过对产生式P施加限制，将文法分成四类：

+ 0型文法：短文文法，或无限制文法

+ 1型文法：上下文有关文法，或长度增加文法

+ **2型文法：上下文无关文法**(Context Free Grammar)

  + 可用于描述短语和句子的语法规则

+ **3型文法：正规文法(Regular Grammar)，不是右线性文法，就是左线性文法**

  + 可用于描述单词的词法规则

  

##### 0型文法（无限制）

+ 对产生式$\alpha \rarr \beta$
  + 左部至少包含一个非终结符
  + 右部可以为空或任意组合

+ 范围最大，对产生式限制最少

+ 又称短文文法或无限制文法
+ 识别0型语言的自动机——**图灵机（Turing Machine)**



##### 1型文法（上下文有关）

+ 对产生式$\alpha A\beta \rarr \alpha\gamma\beta$
  + 左部至少一个非终结符
  + 左部长度$\le$右部长度
    + 左部非终结符可以替换为非终结符或终结符
    + **只有当左部为一个非终结符时，才可以替换为空串**，而且非终结符不能出现在其他产生式的右部
+ 又称**上下文有关文法**，替换非终结符时，必须考虑上下文

+ 或**长度增加文法，每次替换长度都会增加**
+ 识别1型文法的自动机叫**线性有界自动机**（Linear  Bounded Automaton)



##### 2型文法（上下文无关）

+ 对$A \rarr \beta$
  + 左部**只能有一个非终结符**
  + 右部任意（空、非终结符、终结符或组合）
+ 又称**上下文无关文法**(Context Free Grammar)，替换非终结符时，无需考虑上下文
+ 自动机叫**下推自动机**(PDA)
+ 当终结符集合的元素包括单词时，可判断单词间的组合（句子）是否正确



> 非终结符或终结符可以映射为概念或单词
>
> 尤其在语法分析中，一般用单个终结符代表一个单词



##### 3型文法（正规文法）

+ **正规文法**，可分为**右线性文法**或**左线性文法**
  + 右线性：$A\rarr \alpha B 或 A\rarr \alpha$
  + 左线性：$A\rarr B\alpha 或 A\rarr \alpha$
  + $A,B是非终结符，\alpha是非终结符$
  + **左右线性不能混用，即正规文法的P要么全是左线性，要么全是右线性**
+ 右线性文法（见上述字母表述）
  + 左部只能有一个终结符
  + 右部可以是一串终结符，或一串终结符右边一个非终结符
+ 正规文法的限制最严格
+ 对应自动机叫**有限状态自动机**
+ 一般用来判断一个单词是否正确

##### 结论

+ 四种文法的包含关系(强度：3 > 2 > 1 > 0)

  + 3型一定是2型
  + 2型一定是1型
  + 1型一定是0型

+ 由n型文法生成的语言，称作n型语言

  即3型文法生成的语言叫3型语言

+ 若L(G1) = L(G2)，则称文法G1和G2是等价的



### 三、文法的构造与简化

#### 文法的构造

例题见视频4.2

##### 一个语言可以构造出多种文法



#### 文法的简化

##### 文法的产生式必须有用，即不应该存在：

+ 形如$P\rarr P$的产生式
+ 永远都推不出终结符的产生式
+ 永远用不到的产生式

例题见视频4.2 7:40

+ 总是试图推出终结符，推不出则该产生式错误



### 四、语法树与文法的二义性

#### 语法树

##### 定义：用来表示语言句子结构的树

##### 作用：使分析过程更直观抽象，易与判断文法二义性

##### 构造（视频4.3 3:00)

+ 每个符号都要有一个分支

+ 扩展的任意时刻，**所有叶子结点从左往右的排列即为一个句型**

+ 最右推导的规范句型叫右句型**（总是替换最右边的非终结符）**
+ **叶子结点一定是终结符**



##### 短语，直接短语，句柄

+ 短语可以包含终结符和非终结符
+ 某个结点的短语包括每个子节点的短语，所有叶子结点从左到右排列得到子结点的短语
+ **叶子结点的上一层**的**非终结符的所有叶子结点排列**，是**直接短语**
+ 最左边的直接短语叫**句柄**
+ 句子是最后推导出的所有非终结符
+ **任意时刻，句柄是唯一的**





#### 文法的二义性

+ **句子**的二义性：若文法的一个句子存在两棵或两棵以上的的语法树，则称该句子是二义的

+ 即只要文法包含一条二义性句子，该文法就是二义性文法
+ 不存在判断二义性的算法
+ 避免二义性，可简化语法分析过程



****

## 第三章 词法分析

### 一、词法分析程序的设计

### 思路

1. 写出每种单词的词法规则（正规文法或正规式）
2. 将词法规则转换为相应的有限自动机（用状态转换图表示）
3. 将多个有限自动机的初态连接起来，构成识别该语言的自动机
4. 编写程序实现自动机（采用条件分支语句P41)
   + 从初态出发，识别得到每一个单词后进入终态
   + 调用语法分析程序，传递一个包含单词的二元式
   + 若语法分析程序需要下一个单词，就调用词法分析程序



### 二、正规文法（3型文法）

#### 3型文法概念

见第二章

+ 分为左线性和右线性、

##### 左线性：

+ 从右到左
+ 开头是出口（**限制开头的字符串适合用左线性**）



##### 右线性：

+ 从左到右
+ 结尾是出口（**限制结尾的字符串适合用右线性**）

#### 例题

见视频5-2

### 三、正规式（正则表达式）

#### 3型语言的另一种表示方式——正则表达式RE

+ 某个正规式产生的所有值的集合叫做正规集（regular set）
+ 即**3型语言又称正规集**

+ 有些语言便于用文法表示，有些便于用正则表达式表示

+ **正规文法可以通过解方程的方法转换为正则表达式**（P47 例3.5）
+ **正规式通过一定的重写规则转换为正规文法**（P46 例3.4)
  + 若正规式复杂，则过程很复杂



#### 正规式

描述了单词的**排列规律**

##### 正规式的符号运算

+ 或：a|b
+ 连接：ab
+ 闭包：a*
+ 运算优先级：闭包>连接>或，括号最优先



##### 正规式的运算律

+ 分配律：a(b|c) = ab|ac                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

+ 或的交换律、结合律
+ 连接的结合律
+ 空串连接：$\epsilon a = a\epsilon = a$



##### 例题见视频5-3





### 四、有限状态自动机

#### 概念

##### 功能

一种识别装置，能准确地识别正规集，即识别正规文法定义的语言和正规式表示的集合

##### 分两类

+ 确定的有限自动机（**Deterministic Finite Automata**)
+ 不确定的有限自动机（**Nondeterministic Finite Automata**）

##### 三种表示

+ 状态转换图
+ 状态转换矩阵
+ 状态转换函数

##### 状态转换图

+ 结点：状态
+ 边权：当前指向的符号
+ 无起点的箭头：指向开始状态（或初态）
+ **双圆圈**：结束状态（终态）

##### 状态转换矩阵

+ $f(i,j)=k$

+ 行下标*i*：状态（序号）
+ 列下标*j*：边权（符号）
+ 值*k*：下一个状态

##### 状态转换函数 f(i, j) = k(同矩阵)



##### 识别某程序语言中的所有符号的有限自动机

+ **即对所有单词构造一个自动机，并把所有初态连起来**
+ 包含识别标识符、常量（字符串/数字）、保留字、符号的自动机



**有限状态自动机的状态转换，可通过条件分歧实现**





#### DFA

##### 特征

+ **只有一个初态，可以有多个终态**
+ **一个结点只有一个出度**
+ **终态集可以为空**

##### 数学模型

**五元式$M = (S, \Sigma, f, s_0, Z)$**

+ S(state set)：有限状态集

+ $\Sigma$(input symbol set)：有限字母表（**终结符**）

+ f(transition function)：转换函数

  + $S\cross \Sigma\rarr S$
  + 含义：S中的某个状态，读取到$\Sigma$中的某个符号后，将状态转换为S中的某个状态。可写成$f(s, a) = s^{’}$
  + 确定的单值映射

+ $s_0$（start state)：初态

  + s小写，$s_0\in S$
  + **初态唯一**

+ Z(accept state set)：终态集

  **$Z\in S$，Z可以为空**

##### 表示（P48）

+ DFA有m个状态，n个输入符号，则**每个结点最多有n个弧射出**
+ 状态转换图是一种特殊的有向图

**自动机可以通过连接初态进行组合**



#### NFA

##### 特征

+ **可以有多个初态**

+ **一个结点可能有多个后继**
+ **存在权值为空串$\epsilon$的边（不需要任何条件就可直接跳到下一个状态）**

##### 数学模型

**五元式$M=(S, \Sigma, f, S_0, Z)$**

+ 意义同DFA

+ $S_0$: S大写

+ **转换函数f的值是一个集合（转换为S中的任意个数的状态）**

  $S\cross\Sigma\rarr 2^S$

+ **Z可以为空**

##### NFA更符合现实场景

+ 例如直接将正规文法或正规式转换为自动机一般都是NFA
+ 但计算机程序很难处理NFA，需要转换为DFA



### 五、NFA转DFA(NFA的确定化)

#### 等价FA

+ 若任何两个有穷自动机**识别的语言相同**，则称这两个自动机等价
+ NFA通过**子集法**将其**确定化**，可转换为一个等价的DFA
+ 转换后的DFA一般存在冗余，可通过**划分法**进一步**简化**



#### 任务

+ **$由NFA: M=(S, \Sigma, f, S_0, Z)构造一个等价的DFA: M^{'}=(Q, \Sigma, \delta, I_0, F)$**

  字母表$\Sigma$不变

+ 两种情况：
  + **带$\epsilon 弧的NFA$**
  + **不带$\epsilon 弧的NFA$**



#### 不带空弧的NFA（子集法）

**$由NFA: M=(S, \Sigma, f, S_0, Z)构造一个等价的DFA: M^{'}=(Q, \Sigma, \delta, I_0, F)$**

1. $令M^{'}的初态集为s_0，M^{'}的状态集Q=\{I_0\}$

2. $逐个检查Q中每个元素，对任意元素I：$（**I是一个集合**）

   $对字母表\Sigma中任意符号a：$

   + $求I中每个状态读到a后到达的另一个集合的状态的集合，求并集，得到一个临时集合，$

     $即，f(s_0, a)\cup f(s_1, a)\cup ... = \{s_0, s_1,...\}$

   + $如果该集合\in Q,不处理；否则加入Q$

3. $重复步骤2, 直到没有新集合加入Q$

4. $对于NFA的终态集中的任意状态s：$

   $若s\in Q中任一元素I，则将I将入M^{'}的终态集F$



#### 带空弧的NFA

##### 算法思路和不带空弧时相同

##### 空弧导致的问题：

1. 状态1通过读取a到达状态2，状态2通过读取空弧可以无条件到达状态3，

   状态3再无条件到达状态4...

2. 增加了算法第二步求临时集合的复杂度

##### $\epsilon-闭包(\epsilon-closure)$

+ 状态s经过0条以上空弧可能到达的状态的集合，即包括s
+ 状态s的闭包写作$\epsilon-closure(s)$
+ 状态集I的闭包写作$\epsilon-closure(I)，是集合I中所有状态的闭包的并集$

##### 算法（兼容不带空弧的NFA）

**$由NFA: M=(S, \Sigma, f, S_0, Z)构造一个等价的DFA: M^{'}=(Q, \Sigma, \delta, I_0, F)$**

1. $算出每个状态的\epsilon-closure，令M^{'}的初态集I_0为\epsilon-closure(S_0)(即初态可以无条件到达的状态都看成初态)$

   $令M^{'}的状态集Q=\{I_0\}$

2. $逐个检查状态集Q里的元素，对于每个I：（I是集合）$

   $对\Sigma中的任意符号a：$

   1. $求I中每个状态读到a后到达的另一个状态的集合，求其并集，求该集合的闭包，得到临时集合，$

      $即\epsilon-closure(f(s_0, a)\cup f(s1, a) \cup...) = \epsilon-closure(\{s_0, s_1, ...\}) = \{s_0, s_1, ...\}$

   2. $将临时集合加入Q（存在则不处理）$

3. $重复2，直到没有新的状态加入Q$

4. $对于NFA的终态集中的任意状态s：$

   $若s\in Q中任一元素I，则将I将入M^{'}的终态集F$



##### 例题见视频7-1 13:00





#### DFA的简化（分隔法）

##### 步骤（例题见视频7-2）

1. 画状态转换矩阵

2. 状态集分为终态集和非终态集

3. **检查非终态集**：

   若集合中的所有元素经过$\Sigma中$一个符号的后继状态状态不在同一个集合，则要根据**后继状态将原非终态集元素分类**

   分类后每个集合内元素的后继状态都处于同一个集合

4. 检查终态集（同3），直到不可分割

5. 合并等价子集：将每个集合所有元素替换成根结点（类似并查集）





### 六、正规文法与自动机的转换

#### 定理

$文法G= (V_N, V_T, P, S)是一个正规文法，则必存在自动机M=(S, \Sigma, f, s_0, Z), 使正规集L(G) = L(M)$

+ 正规文法分左线性和右线性，即一个自动机对应多个文法

#### 右线性文法转换NFA

##### 构造右线性文法$G= (V_N, V_T, P, S)$的等价NFA $M=(S, \Sigma, f, S_0, Z)$的方法：

1. M的字母表$\Sigma = V_T$

2. M的开始状态$Q_0 = \{S\}$
3. 令终态F暂时等于{Z},**其中Z不属于$V_N$**（在非终结符里加一个新的符号）
4. M的**状态集**$Q = V_N \cup {Z}$
5. 将产生式**集合P转换为d转换函数f**：
   + 对$A\rarr aB$,添加$f(A, a) = B$
   + 对$A\rarr B$，添加$f(A, \epsilon) = B$
   + 对$A\rarr a$，添加$f(A, a) = Z$
   + 对$A\rarr \epsilon$，将A添加到**终态集F**中



#### DFA转换右线性文法(不实用)

##### 构造DFA $M=(S, \Sigma, f, S_0, Z)$的等价右线性文法$G= (V_N, V_T, P, S)$的方法：

1. $构造P：$
   1. $对M中任意f(A, a) = B，添加A\rarr aB$
   2. $若B属于终态集Z, 再添加A\rarr a$
2. $若开始状态s_0属于终态集Z, 再添加产生式：s_0'\rarr \epsilon|s_0。并将开始符号改为s_0'$





### 七、正则表达式与自动机的转换

#### 定理

$任意字母表\Sigma上的NFA所能识别的语言L(M)可以用\Sigma上的正规式来表示。即对\Sigma上的$

$NFA M, 存在一个正规式\alpha，使得L(\alpha) = L(M)$

#### NFA换正规式

##### 1. NFA M的状态转换图上添加两个结点x和y，得到一个新的NFA $M^{'}$,其中：

+ $x用\epsilon弧连M的所有初态$
+ $M的所有终态用\epsilon弧连y$

##### 2. 三条替换规则逐步消去所有结点，最终只剩下x和y

+ 串行转连接
+ 并行转或
+ 自循环转闭包

##### 3. 删完后得到的弧上的符号即正规式



#### 正规式转NFA

##### 1. 画转换图，包括两个结点x和y

+ x是初态，y是终态，正规式是x到y弧上的符号

##### 2. 三条分裂规则，将图展开

+ 连续两个符号，构造新结点，转为两个弧
+ 或：转为并行的弧
+ 闭包*：构造新结点，新结点上画自环，两边是空弧

##### 3. 直到每个弧上只有一个字符

##### 4. NFA确定化转为DFA





****

## 第四章 语法分析

