编译原理笔记by以禾

****

## 第二章 文法和语言

### 一、描述语言的工具

#### 字母表与符号

##### 字母表

+ 非空的有穷集合
+ 用$V或\sum$表示
+ 如$V=\{a, b, ..., z\}, \sum=\{+,*,1, 2, ..., 9, 0, (, )\}$等
+ 符号或符号串

##### 符号

+ 最基本、不可分的单位
+ 不具备语法意义（**与单词作区分**）

##### 符号串

+ 字母表上的符号组成的有穷序列
+ 用$\alpha,\beta,\gamma...表示$
+ **空串：$\epsilon$**

##### 句子和语言

+ 句子：字母表上元素按照某种规则组成的串的集合
+ 语言：字母表上**句子的集合**，用L表示

+ 句子集合：A={a=b,if a then b, ...}

#### 符号串集合的运算

##### 连接（乘积）

+ 顺序很重要，$\alpha\beta \ne \beta\alpha$
+ 集合的乘积即相应每个元素的互相排列组合（**区分顺序**）

##### 方幂（次方）

+ 与自身的乘积
+ $对于集合A,A^0={\epsilon},A^1=A,A^2=AA,...$

##### 闭包（closure）

+ 某字母表可生成的所有符号串的集合
+ **集合中任意个元素的任意运算结果都在集合内（运算封闭）**
+ 用$A^*或closure(A)$表示
+ **$A^*=A^0 \cup A^1 \cup A^2 \cup ...$**

##### 正闭包（positive closure)

+ 闭包减去空串
+ 用$A^+$表示
+ $A^+ = A^1\cup A^2 \cup ... = A^*-\{\epsilon\}$

> 语言是**字母表上正闭包的真子集**

+ 任何一个程序（字符串）时字母表上闭包里的一个元素（**任意长度的字符串都在字母表闭包里**）



### 二、文法概念

>  文法（或语法grammar)是描述语言的形式规则
>
> 采用**形式语言**的方式表示文法
>
> + 用数字或公式定义语言

#### 标识符文法 = （非终结符，终结符，产生式，开始符号）

##### 产生式(Productions)

+ 又称规则、重写规则、生成式
+ 定义了符号串之间关系的一组语法规则
+ 采用BNF(**Backus-Naur Form**)等形式，如：$A\rarr \alpha$,读作**A产生$\alpha$**，或A定义$\alpha$
  + **左部或右部只能有一个字母**
  + 箭头可用:=或::=表示
+ 产生式的集合一般用P表示

##### 开始符号（start symbol）

+ 又称识别符
+ 第一个产生式左侧的非终止符
+ 用S表示

##### 非终结符（non-terminals)

+ 出现在产生式箭头左侧的符号（也可以在右边）
+ 用<...>表示一种语法概念，或**大写字母A、B...**
+ **用$V_N$表示非终结符集合**

##### 终结符（terminals）

+ 语言中不可再分割的符号串
+ j产生式箭头**右侧的小写字母、符号、单词**的集合
+ **用$V_T$表示终结符集合**



##### 文法的形式定义

+ 文法$G={V_N,V_T,P,S},其中V_N=\{A,B,...\},V_T=\{a,b,...,+,*,...\}$

  P由下列产生式组成：

  1. $S\rarr...$
  2. ...

+ **可缩写为：**（只要知道了开始符合产生式就能知道终结符和非终结符）

  G[S]：

  1. $S\rarr...$
  2. 



#### 推导与规约

##### 推导(derive)

+ 由开始符号起，通过**替换掉非终结符**，最终得到由终结符组成的**字符串**的过程
+ 规范推导：最左推导或最右推导（只替换左或右）

+ 推导符号：
  + **直接推导**：$\Rarr$
  + **一步以上推导**：$\Rarr^+$
  + **零步以上推导**：$\Rarr^*$

##### 规约(reduce)

+ 推导的逆过程
+ 由字符串开始，反推回开始符号
+ 规范规约，符号同推导



#### 句型、句子、语言时

##### (规范)句型：(规范)推导的中间结果

+ 从开始符号起，包括零步在内，每一步推导得到的符号串

##### 句子：仅含终结符的句型

+ 推导的最终结果

##### 语言：所有句子的集合

+ 推导出的句子的集合





#### 文法的类型

##### 文法$G=(V_N,V_T,P,S)$

##### Chomsky通过对产生式P施加限制，将文法分成四类：

+ 0型文法：短文文法，或无限制文法

+ 1型文法：上下文有关文法，或长度增加文法

+ **2型文法：上下文无关文法**(Context Free Grammar)

  + 可用于描述短语和句子的语法规则

+ **3型文法：正规文法(Regular Grammar)，不是右线性文法，就是左线性文法**

  + 可用于描述单词的词法规则

  

##### 0型文法（无限制）

+ 对产生式$\alpha \rarr \beta$
  + 左部至少包含一个非终结符
  + 右部可以为空或任意组合

+ 范围最大，对产生式限制最少

+ 又称短文文法或无限制文法
+ 识别0型语言的自动机——**图灵机（Turing Machine)**



##### 1型文法（上下文有关）

+ 对产生式$\alpha A\beta \rarr \alpha\gamma\beta$
  + 左部至少一个非终结符
  + 左部长度$\le$右部长度
    + 左部非终结符可以替换为非终结符或终结符
    + **只有当左部为一个非终结符时，才可以替换为空串**，而且非终结符不能出现在其他产生式的右部
+ 又称**上下文有关文法**，替换非终结符时，必须考虑上下文

+ 或**长度增加文法，每次替换长度都会增加**
+ 识别1型文法的自动机叫**线性有界自动机**（Linear  Bounded Automaton)



##### 2型文法（上下文无关）

+ 对$A \rarr \beta$
  + 左部**只能有一个非终结符**
  + 右部任意（空、非终结符、终结符或组合）
+ 又称**上下文无关文法**(Context Free Grammar)，替换非终结符时，无需考虑上下文
+ 自动机叫**下推自动机**(PDA)
+ 当终结符集合的元素包括单词时，可判断单词间的组合（句子）是否正确



> 非终结符或终结符可以映射为概念或单词
>
> 尤其在语法分析中，一般用单个终结符代表一个单词



##### 3型文法（正规文法）

+ **正规文法**，可分为**右线性文法**或**左线性文法**
  + 右线性：$A\rarr \alpha B 或 A\rarr \alpha$
  + 左线性：$A\rarr B\alpha 或 A\rarr \alpha$
  + $A,B是非终结符，\alpha是非终结符$
  + **左右线性不能混用，即正规文法的P要么全是左线性，要么全是右线性**
+ 右线性文法（见上述字母表述）
  + 左部只能有一个终结符
  + 右部可以是一串终结符，或一串终结符右边一个非终结符
+ 正规文法的限制最严格
+ 对应自动机叫**有限状态自动机**
+ 一般用来判断一个单词是否正确

##### 结论

+ 四种文法的包含关系(强度：3 > 2 > 1 > 0)

  + 3型一定是2型
  + 2型一定是1型
  + 1型一定是0型

+ 由n型文法生成的语言，称作n型语言

  即3型文法生成的语言叫3型语言

+ 若L(G1) = L(G2)，则称文法G1和G2是等价的



### 三、文法的构造与简化

#### 文法的构造

例题见视频4.2

##### 一个语言可以构造出多种文法



#### 文法的简化

##### 文法的产生式必须有用，即不应该存在：

+ 形如$P\rarr P$的产生式
+ 永远都推不出终结符的产生式
+ 永远用不到的产生式

例题见视频4.2 7:40

+ 总是试图推出终结符，推不出则该产生式错误



### 四、语法树与文法的二义性

#### 语法树

##### 定义：用来表示语言句子结构的树

##### 作用：使分析过程更直观抽象，易与判断文法二义性

##### 构造（视频4.3 3:00)

+ 每个符号都要有一个分支

+ 扩展的任意时刻，**所有叶子结点从左往右的排列即为一个句型**

+ 最右推导的规范句型叫右句型**（总是替换最右边的非终结符）**
+ **叶子结点一定是终结符**



##### 短语，直接短语，句柄

+ 短语可以包含终结符和非终结符
+ 某个结点的短语包括每个子节点的短语，所有**叶子结点从左到右排列**得到子结点的短语（**短语一定是叶子结点的排列**）
+ **所有短语：当前语法树所有非叶结点的短语**
+ **叶子结点的上一层**的**非终结符的所有叶子结点排列**，是**直接短语**
+ 最左边的直接短语叫**句柄**
+ 句子是最后推导出的所有终结符（**句子只包含终结符，句型无限制**）
+ **任意时刻，句柄是唯一的**





#### 文法的二义性

+ **句子**的二义性：若文法的一个句子存在两棵或两棵以上的的语法树，则称该句子是二义的

+ 即只要文法包含一条二义性句子，该文法就是二义性文法
+ 不存在判断二义性的算法
+ 避免二义性，可简化语法分析过程



****

## 第三章 词法分析

### 一、词法分析程序的设计

### 思路

1. 写出每种单词的词法规则（正规文法或正规式）
2. 将词法规则转换为相应的有限自动机（用状态转换图表示）
3. 将多个有限自动机的初态连接起来，构成识别该语言的自动机
4. 编写程序实现自动机（采用条件分支语句P41)
   + 从初态出发，识别得到每一个单词后进入终态
   + 调用语法分析程序，传递一个包含单词的二元式
   + 若语法分析程序需要下一个单词，就调用词法分析程序



### 二、正规文法（3型文法）

#### 3型文法概念

见第二章

+ 分为左线性和右线性、

##### 左线性：

+ 从右到左
+ 开头是出口（**限制开头的字符串适合用左线性**）



##### 右线性：

+ 从左到右
+ 结尾是出口（**限制结尾的字符串适合用右线性**）

#### 例题

见视频5-2

### 三、正规式（正则表达式）

#### 3型语言的另一种表示方式——正则表达式RE

+ 某个正规式产生的所有值的集合叫做正规集（regular set）
+ 即**3型语言又称正规集**

+ 有些语言便于用文法表示，有些便于用正则表达式表示

+ **正规文法可以通过解方程的方法转换为正则表达式**（P47 例3.5）
+ **正规式通过一定的重写规则转换为正规文法**（P46 例3.4)
  + 若正规式复杂，则过程很复杂



#### 正规式

描述了单词的**排列规律**

##### 正规式的符号运算

+ 或：a|b
+ 连接：ab
+ 闭包：a*
+ 运算优先级：闭包>连接>或，括号最优先



##### 正规式的运算律

+ 分配律：a(b|c) = ab|ac                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

+ 或的交换律、结合律
+ 连接的结合律
+ 空串连接：$\epsilon a = a\epsilon = a$



##### 例题见视频5-3





### 四、有限状态自动机

#### 概念

##### 功能

一种识别装置，能准确地识别正规集，即识别正规文法定义的语言和正规式表示的集合

##### 分两类

+ 确定的有限自动机（**Deterministic Finite Automata**)
+ 不确定的有限自动机（**Nondeterministic Finite Automata**）

##### 三种表示

+ 状态转换图
+ 状态转换矩阵
+ 状态转换函数

##### 状态转换图

+ 结点：状态
+ 边权：当前指向的符号
+ 无起点的箭头：指向开始状态（或初态）
+ **双圆圈**：结束状态（终态）

##### 状态转换矩阵

+ $f(i,j)=k$

+ 行下标*i*：状态（序号）
+ 列下标*j*：边权（符号）
+ 值*k*：下一个状态

##### 状态转换函数 f(i, j) = k(同矩阵)



##### 识别某程序语言中的所有符号的有限自动机

+ **即对所有单词构造一个自动机，并把所有初态连起来**
+ 包含识别标识符、常量（字符串/数字）、保留字、符号的自动机



**有限状态自动机的状态转换，可通过条件分歧实现**





#### DFA

##### 特征

+ **只有一个初态，可以有多个终态**
+ **一个结点只有一个出度**
+ **终态集可以为空**

##### 数学模型

**五元式$M = (S, \Sigma, f, s_0, Z)$**

+ S(state set)：有限状态集

+ $\Sigma$(input symbol set)：有限字母表（**终结符**）

+ f(transition function)：转换函数

  + $S\cross \Sigma\rarr S$
  + 含义：S中的某个状态，读取到$\Sigma$中的某个符号后，将状态转换为S中的某个状态。可写成$f(s, a) = s^{’}$
  + 确定的单值映射

+ $s_0$（start state)：初态

  + s小写，$s_0\in S$
  + **初态唯一**

+ Z(accept state set)：终态集

  **$Z\in S$，Z可以为空**

##### 表示（P48）

+ DFA有m个状态，n个输入符号，则**每个结点最多有n个弧射出**
+ 状态转换图是一种特殊的有向图

**自动机可以通过连接初态进行组合**



#### NFA

##### 特征

+ **可以有多个初态**

+ **一个结点可能有多个后继**
+ **存在权值为空串$\epsilon$的边（不需要任何条件就可直接跳到下一个状态）**

##### 数学模型

**五元式$M=(S, \Sigma, f, S_0, Z)$**

+ 意义同DFA

+ $S_0$: S大写

+ **转换函数f的值是一个集合（转换为S中的任意个数的状态）**

  $S\cross\Sigma\rarr 2^S$

+ **Z可以为空**

##### NFA更符合现实场景

+ 例如直接将正规文法或正规式转换为自动机一般都是NFA
+ 但计算机程序很难处理NFA，需要转换为DFA



### 五、NFA转DFA(NFA的确定化)

#### 等价FA

+ 若任何两个有穷自动机**识别的语言相同**，则称这两个自动机等价
+ NFA通过**子集法**将其**确定化**，可转换为一个等价的DFA
+ 转换后的DFA一般存在冗余，可通过**划分法**进一步**简化**



#### 任务

+ **$由NFA: M=(S, \Sigma, f, S_0, Z)构造一个等价的DFA: M^{'}=(Q, \Sigma, \delta, I_0, F)$**

  字母表$\Sigma$不变

+ 两种情况：
  + **带$\epsilon 弧的NFA$**
  + **不带$\epsilon 弧的NFA$**



#### 不带空弧的NFA（子集法）

**$由NFA: M=(S, \Sigma, f, S_0, Z)构造一个等价的DFA: M^{'}=(Q, \Sigma, \delta, I_0, F)$**

1. $令M^{'}的初态集I_0为s_0，并加入状态集Q$

2. $求状态集Q：对Q中每个I：$（**I是一个集合**）

   $求出I中所有元素对于同一边权的邻接点构成的集合，并入Q$

   $重复操作直到没有新元素加入Q$

4. $求终态集：对Q中所有含原NFA终态集中任一元素的集合加入DFA的终态集$




#### 带空弧的NFA

##### 算法思路和不带空弧时相同

##### 空弧导致的问题：

1. 状态1通过读取a到达状态2，状态2通过读取空弧可以无条件到达状态3，

   状态3再无条件到达状态4...

2. 增加了算法第二步求临时集合的复杂度

##### $\epsilon-闭包(\epsilon-closure)$

+ 状态s经过0条以上空弧可能到达的状态的集合，即包括s
+ 状态s的闭包写作$\epsilon-closure(s)$
+ 状态集I的闭包写作$\epsilon-closure(I)，是集合I中所有状态的闭包的并集$

##### 算法（兼容不带空弧的NFA）

**$由NFA: M=(S, \Sigma, f, S_0, Z)构造一个等价的DFA: M^{'}=(Q, \Sigma, \delta, I_0, F)$**

1. $算出每个状态的\epsilon-closure，令M^{'}的初态集I_0为\epsilon-closure(S_0)(即初态可以无条件到达的状态都看成初态)$

   $令M^{'}的状态集Q=\{I_0\}$

2. $逐个检查状态集Q里的元素，对于每个I：（I是集合）$

   $对\Sigma中的任意符号a：$

   1. $求I中每个状态读到a后到达的另一个状态的集合，求其并集，求该集合的闭包，得到临时集合，$

      $即\epsilon-closure(f(s_0, a)\cup f(s1, a) \cup...) = \epsilon-closure(\{s_0, s_1, ...\}) = \{s_0, s_1, ...\}$

   2. $将临时集合加入Q（存在则不处理）$

3. $重复2，直到没有新的状态加入Q$

4. $对于NFA的终态集中的任意状态s：$

   $若s\in Q中任一元素I，则将I将入M^{'}的终态集F$



##### 例题见视频7-1 13:00





#### DFA的最小化/简单化（分隔法）

##### 步骤（例题见视频7-2）

1. 画状态转换矩阵

2. 状态集分为终态集和非终态集

3. **检查非终态集**：

   若集合中的所有元素经过$\Sigma中$一个符号的后继状态状态不在同一个集合，则要根据**后继状态将原非终态集元素分类**

   使得分类后每个集合内元素的后继状态都处于同一个集合

4. 检查终态集（同3），直到不可分割

5. 合并等价子集：将每个集合所有元素替换成根结点（类似并查集）





### 六、正规文法与自动机的转换

#### 定理

$文法G= (V_N, V_T, P, S)是一个正规文法，则必存在自动机M=(S, \Sigma, f, s_0, Z), 使正规集L(G) = L(M)$

+ 正规文法分左线性和右线性，即一个自动机对应多个文法

#### 右线性文法转换NFA

##### 构造右线性文法$G= (V_N, V_T, P, S)$的等价NFA $M=(S, \Sigma, f, S_0, Z)$的方法：

1. M的字母表$\Sigma = V_T$

2. M的开始状态$Q_0 = \{S\}$
3. 令终态F暂时等于{Z},**其中Z不属于$V_N$**（在非终结符里加一个新的符号）
4. M的**状态集**$Q = V_N \cup {Z}$
5. 将产生式**集合P转换为d转换函数f**：
   + 对$A\rarr aB$,添加$f(A, a) = B$
   + 对$A\rarr B$，添加$f(A, \epsilon) = B$
   + 对$A\rarr a$，添加$f(A, a) = Z$
   + 对$A\rarr \epsilon$，将A添加到**终态集F**中



#### DFA转换右线性文法(不实用)

##### 构造DFA $M=(S, \Sigma, f, S_0, Z)$的等价右线性文法$G= (V_N, V_T, P, S)$的方法：

1. $构造P：$
   1. $对M中任意f(A, a) = B，添加A\rarr aB$
   2. $若B属于终态集Z, 再添加A\rarr a$
2. $若开始状态s_0属于终态集Z, 再添加产生式：s_0'\rarr \epsilon|s_0。并将开始符号改为s_0'$





### 七、正则表达式与自动机的转换

#### 定理

$任意字母表\Sigma上的NFA所能识别的语言L(M)可以用\Sigma上的正规式来表示。即对\Sigma上的$

$NFA M, 存在一个正规式\alpha，使得L(\alpha) = L(M)$

#### NFA换正规式

##### 1. NFA M的状态转换图上添加两个结点x和y，得到一个新的NFA $M^{'}$,其中：

+ $x用\epsilon弧连M的所有初态$
+ $M的所有终态用\epsilon弧连y$

##### 2. 三条替换规则逐步消去所有结点，最终只剩下x和y

+ 串行转连接
+ 并行转或
+ 自循环转闭包

##### 3. 删完后得到的弧上的符号即正规式



#### 正规式转NFA

##### 1. 画转换图，包括两个结点x和y

+ x是初态，y是终态，正规式是x到y弧上的符号

##### 2. 三条分裂规则，将图展开

+ 连续两个符号，构造新结点，转为两个弧
+ 或：转为并行的弧
+ 闭包*：构造新结点，新结点上画自环，两边是空弧

##### 3. 直到每个弧上只有一个字符

##### 4. NFA确定化转为DFA





****

## 第四章 自上而下语法分析

### 一、语法分析与下推自动机

#### 语法分析是编译的第二个阶段（核心）

+ 先判断单词序列是否符合文法

##### 语法分析程序的步骤

1. 调用一次词法分析程序
2. 判断已读入的二元式串是否能进行推导或规约，若能，则
   + 推导或规约
   + 调用一次语义分析程序

##### 理论基础

+ 2型文法（上下文无关文法Context Free Grammar）
+ 下推自动机PDA



#### 2型文法和3型文法的区别

##### 词法分析用的是3型正规文法

+ 只要产生式不重复，则不存在二义性文法
+ 正规文法无法保存”推导次数“这个概念

##### 语法分析用2型上下文无关文法

+ 存在二义性文法
+ 导入一个下推栈



#### 下推自动机

##### 模型

PDA数学模型$M = (S, \Sigma, Z, f, s_0, z_0, F)$

+ 有限状态自动机加上一个下推栈
  + Z为栈中允许存储的符号的字母表（终结符+非终结符+#号）
  + z_0为栈顶元素
  + 栈底用#号表示
+ 遍历所有二元式，每次将key入栈，根据**栈中内容与预测表**中的元素对比，匹配则出栈，完成一个产生式的分析

+ **预测表是核心**



#### 语法分析的两种方式

##### 1. 自上而下的语法分析（基于推导）

+ 自顶向下Top-Down Parsing
+ 反复使用不同的产生式，通过**推导**得到匹配的句子
+ 常见方法：
  + 不确定自上而下分析：回溯法（即枚举）
  + 确定自上而下分析：**递归下降法(DFS)、预测分析法（手动实现递归栈）**
+ 核心问题：**推导时选择那个产生式？根据读头下的单词预测**

##### 2. 自下而上的语法分析（基于归约）

+ 自底向上（Bottom-Up Parsing）

+ 对输入符号串寻找不同产生式，通过**归约**得到文法的开始符号

+ 常见方法

  + **优先分析法**：简单优先、算符优先
  + **LR分析法**：LR(0)、SLR(1)、LR(1)、LALR(1)

+ 核心问题：如何判断归约的时机？

  **寻找句柄（handle）**



### 二、不确定的自上而下分析与问题

推倒时可能遇到存在多个候选产生式的情况，最简单的解决方法是**尝试法**，选择任意一个产生式，若出错则回溯

##### 算法：

1. 初始化

   + 在输入字符串后添加结束符号#
   + 往栈内push#和S（即栈顶为S)
   + 读头指向第一个二元式

2. 循环操作，直至识别结束（结束时，读头和栈顶都是#）

   + **栈顶是非终结符：**进行**推导**，选取一个左边为栈顶符号的产生式，

     先pop，再将整个产生式反向入栈（使得栈顶为产生式第一个符号）。

   + **栈顶是终结符且与读头指向的符号相同：**pop+读头后移

   + **栈顶是终结符且与读头指向的符号不同：**匹配失败，当前选择的产生式无法匹配。
     **进行回溯：**将栈和读头恢复到选择当前产生式之前的一步，选择另一个产生式进行推导。
     若回溯到开始符号S且没有可选的产生式，说明识别失败，报错

##### 不确定分析的问题

+ **回溯**算法复杂度太高；候选产生式的选择无依据；出错时**无法指出出错位置**（回溯到开始符号才会报错）

+ **左递归**：文法设计不当

  遇到左递归文法会**陷入死循环**

  > 左递归文法：箭头右边第一个符号等于左边的符号





### 三、LL(1)文法

#### 含义

##### 第一个L：从左到右扫描输入串（left-to-right)

##### 第二个L：采用**最左推导**（leftmost derivation）

##### 1：只根据读头指向的符号就能确定候选产生式

+ 绝大多数程序设计语言采用LL(1)即可**完全消除回溯**

+ 若根据读头下的符号**开始的k个符号**确定候选式，即为**LL(k)**

#### 性质

+ **若文法G是LL(1)文法，就可以进行确定的自上而下分析**

+ 若可为语言L构造一个LL(1)文法，则该语言为**LL(1)语言**
+ LL(1)文法是CFG（上下文无关文法）的子集
+ LL(1)文法都不是二义性文法



#### LL(1)文法的特征

##### 1. 文法不含左递归

##### 2. 文法不需要回溯，每次推导只有一个候选式，即对任意非终结符A：

+ 对A的每个产生式，**第一个终结符都不同**
+ 若A能推出空串，**所有出现A的产生式，紧跟在A后的符号都不能相同**



#### 判断LL(1)文法的步骤

##### 1. 检查是否有左递归

+ 产生式箭头左边的符号不能和右边第一个符号相同
+ 若有相同，则存在左递归，调用**左递归消除算法**

##### 2. 检查是否存在回溯

$方法一：对每个终结符A,检查箭头左边为A的产生式的Follow集的交集是否为空$

1. 计算每个**符号的First集**
2. 计算产生空串的**非终结符的Follow集**
3. 写出所有**产生式的First集**

$方法二：对$**First集含有空串**$的非终结符A，检查First(A)和Follow(A)的交集是否为空$

1. 计算每个符号的First集
2. 计算每个非终结符的Follow集

**若不为空集，则存在回溯，调用消除回溯算法**



#### First集和Follow集

##### 作用

+ **产生式的First集**：即可以推导出该产生式的所有**终结符**的集合

+ 计算产生式的First集需要每个符号的First和Follow集
+ Follow集解决First集包括空串的问题

##### 计算First集

1. **终结符和空串**的First集为自身

2. **非终结符**的First集：**能推导出的所有句型中，所有第一个终结符或空串的集合**

3. **产生式**的First集：

   + $若产生式中没有空串，则First(A\rarr x\beta) = First(x)$

   + $若产生式包含空串：(x可能是\epsilon)$

     + 情形1:$First(A\rarr x\beta),\beta长度大于0$

       用x后面的符号的First集替换掉x取空串的情况
     
      + 情形2:$First(A\rarr x)$
     
        $用Follow(A)替换x取空串的情况$

+ **产生式的FIrst集不能有空串**





##### 非终结符A的Follow集

+ 含义：从开始符号S起，可以推导出的所有句型中，**紧跟在A后的所有终结符**的集合
+ 若A在结尾，相当于A后面是#
+ **Follow集不存在空串（至少是#）**





##### 求非终结符的First集步骤

例题：视频10-1 4:00

1. 按顺序列出所有非终结符，从下往上求
2. 对于非终结符A的所有产生式，列出第一个符号：
   + 第一个符号是终结符或空串，直接写进集合
   + 第一个符号是非终结符B，则求出First(B)后加入First(A)
     + 若B中有空串，则B取空串时，用后面符号的First集替换



##### 求非终结符的Follow集步骤

Follow(A)即所有句型中紧跟在A后的终结符或#的集合

1. 列出所有非终结符（包括S)，从上往下求
2. **将#加入Follow(S)**
3. 对含有非终结符A的所有产生式，列出与A相邻的符号
   1. 与A相邻的是终结符，直接加入集合
   2. A后面没有符号，即$D\rarr ...A$，算出Follow(D)后加入Follow(A)
   3. A后面是非终结符B，即$D\rarr AB...$，则算出First(B)后加入Follow(A).
      + 若First(B)中有空串，则用B后的符号的Follow集替换B取空串的情况
      + 一直到当前产生式的最后一个符号，依然有空串，则用**Follow(D)替换空串**



##### 求产生式的First集步骤

1. 准备所有非终结符的First集和Follow集
2. $First(A\rarr x\beta) = First(x)$
3. 如果First(x)有空串，检查x是否是结尾符号
   + 不是结尾符号，用$First(\beta)替换空串$
   + 是结尾符号，用$Follow(A)替换空串$







### 四、非LL(1)文法转换LL(1)文法

#### 消除回溯

##### 提取左公因子

+ $对产生式A\rarr \alpha\beta_1|\alpha\beta_2|...|\alpha，改写成：$

  $A\rarr\alpha A^{'}$

  $A\rarr\beta_1|\beta_2|...|\epsilon$

+ 通过反复提取左公因子，**有可能**把所有产生式的First集变为两两不相交，即LL(1)文法

+ **提取公因子会增加语法分析的复杂性**
+ 提取公因子**不一定能消除所有回溯**



#### 消除左递归

##### 左递归即产生式左边与右边第一个符号相同

+ 分为直接和间接
+ 间接左递归：$A\rarr Bb, B\rarr Ac$

##### 消除左递归的公式

+ $对产生式P\rarr P\alpha | \beta$，转化为**右线性文法**：（**$\alpha和\beta可以是非终结符$**）

​			$P\rarr\beta P^{'}$

​			$P^{'}\rarr\alpha P^{'}|\epsilon$

​			$\beta不以P开头$

+ 上述产生式的正则表达式为$\beta\alpha*$
+ **本质上是左线性改右线性**

##### 消除直接和间接左递归算法：

1. $所有非终结符记录序号P_1, P_2, ...P_n$

2. $二重循环，将可以替换的非终结符全部替换$

   ```C++
   for(int i = 1; i <= n; i++) {
       for(int j = 1; j < i; j++) {
           若存在Pi->aPjb, Pj->c
           改写为Pi->acb
       }
       用公式消除Pi的直接左递归
   }
   ```

3. 删除从开始符号不能到达的非终结符开头的产生式









### 五、语法分析程序的实现思路

#### LL(1)

##### 对LL(1)文法，可构造自上而下的语法分析程序

+ 基于递归下降（recursive descent parsing)
+ 基于预测分析表（predictive parsing)

##### 对非LL(1)文法，需要转换为LL(1)

+ 并不是所有上下文无关文法都能转换成功
+ 不能转换的可以用自下而上



#### 递归下降程序

##### 优缺点

+ 优点：逻辑清晰直观，子程序中可直接添加语义分析代码
+ 缺点：代码庞大，占用空间多，速度慢

##### 思路

+ 每个非终结符都写个判断函数
+ 每个终结符写个匹配函数
+ 遇到非终结符，递归调用判断函数，直到递归到终结符，进行匹配，匹配失败则报错





#### 预测分析程序

##### 思路

顺序遍历输入串，进行最左推导，根据栈顶符号和当前指针指向的符号来确定当前应选择的操作

+ 栈存放非终结符（初始化为S#)

+ 一次读入一个单词而不是字符（即**遍历的是二元式**）

##### 特征

+ 用堆栈代替递归
+ 基于**预测分析表**：匹配、选择产生式并推导



##### 预测分析表一般用矩阵M[A, x]表示

+ 行：非终结符
+ 列：终结符和#
+ 元素：栈顶为A且当前指向x时，应替换A的产生式，以及出错标志



##### 预测分析表识别过程

1. 栈顶是**终结符**且与读头下符号相同，不操作，出栈+指针后移
2. 替换：栈顶是非终结符，查看M[A, x]
   + M[A, x]是产生式，则进行**替换**（pop+产生式逆序入栈）
   + M[A, x]是出错标志：报错跳出
3. 识别到最后栈顶和读头都是#，说明识别成功；否则识别失败，报错退出



##### 预测分析表的构造

1. 求所有非终结符的First集

2. 求所有非终结符的Follow集

3. 求所有产生式的First集

4. 根据产生式的First集填表

   （A是非终结符，x是终结符，$\alpha是一个整体$（**可以是空串！**））

   1. $x\in First(A\rarr\alpha), 则M[A, x] = \alpha$
   2. $x\not \in First(A\rarr\alpha), 则M[A, x]=出错标志$

##### 性质

+ LL(1)文法的预测分析表一个格子一个元素，

  非LL(1)文法的预测分析表一个格子存在多个元素，**称为重定义项**

+ 判断是否是LL(1)文法：**只需判断预测分析表中是否有重定义项**



##### 例题：视频11-2



*****

## 第六章 语义分析

### 一、语义分析程序的实现思路

#### 语义分析

##### 是编译的第三个阶段

+ 在语法分析推导或归约时被调用
+ 根据选择的产生式右侧，**检查静态语义+翻译中间代码**

##### 中间代码

+ 四元式
+ 三元式
+ 后缀表达式（逆波兰）

##### 问题：如何实现产生式间的值传递？

+ 引入**属性**的概念





#### 语义分析的两种描述形式

##### 语法制导的定义（syntax-directed definitions, SDD）

+ 又称属性文法（attributed grammar)
+ 给产生式的每个符号添加属性，并构造对应的语义规则（**一条产生式两种表达**）



##### 语法制导的翻译方案（syntax-directed translation scheme，SDT）

+ 对产生式构造语义动作（semantic actions）和**动作的插入位置**





#### 声明语句（无四元式）

##### 思路

+ 建立标识符表，包含名称、类型、值三个属性
+ 在`parseDeclaration()`中，`match(int)`后，单词指针指向标识符，此时保存标识符的类型

+ 分析标识符列表时，将所有标识符的类型全部变为int
+ **在match(标识符)之前保存单词，match成功后再更新类型，防止当前单词不是标识符，match匹配失败报错**





#### 赋值语句（=，右操作数，null，左操作数）

##### 伪代码

```C++
parseAssign() {
    保存标识符名：
    match("标识符");
    match("等号");
    创建临时变量E = parseExpression();
    generate(=, E.name, null, 标识符名);
    更新标识符表中的对应值
}
```





#### 算数/逻辑表达式（运算符，左操作数，右操作数，目标操作数）

$E\rarr iE^{'}$

$E^{'}\rarr +EE^{'}|\epsilon$





#### If语句

##### 思路

**对`<条件语句>->if(E) then S`做语法和语义分析步骤：**

| 语法分析   | 语义分析                                                     |
| ---------- | ------------------------------------------------------------ |
| 匹配if     |                                                              |
| 匹配(      |                                                              |
| `parseE()` | 翻译逻辑表达式，产生一系列四元式；<br />`parseE()`结束后返回计算结果，可能是true或false<br />若结果true，**执行then 后S对应的四元式**<br />若结果为false，**跳过then，执行下一条语句** |
| 匹配）     |                                                              |
| 匹配then   |                                                              |
| `parseS()` | 翻译复合语句，产生一系列四元式                               |

+ **表示跳转的四元式：（jnz，E, null, 100或（j, null, null, 100)**



##### 有条件跳转（jnz, 条件变量，null，目标四元式的下标）

+ 条件变量不为0，就跳转到目标四元式
+ **0 == false, 1 == true**
+ 等价于`if 条件变量== true jmp 目标四元式`



##### 无条件跳转（j, null, null, 目标四元式的下标）



##### 条件语句的核心问题：

+ 何时跳转？关注插入语义动作的位置
+ 往哪里跳？**拉链与回填**





**对`<条件语句>->if(E)then S1 else S2`**

| 语法分析    | 语义分析                                                     |
| ----------- | ------------------------------------------------------------ |
| 匹配if      |                                                              |
| 匹配（      |                                                              |
| `parseE()`  | 翻译逻辑表达式，产生四元式<br />`parseE()`结束后返回计算结果<br />结果为true，执行S1<br />结果为false，执行S2 |
| 匹配）      |                                                              |
| 匹配then    |                                                              |
| `parseS1()` | 翻译复合语句，产生四元式<br />跳过else，执行下一条语句       |
| 匹配else    |                                                              |
| `parseS2()` | 翻译符合语句，产生四元式                                     |



**对`C->if(E) then S1 {elseif(E) then S2} else S3`**

| 语法分析           | 语义分析                                                     |
| ------------------ | ------------------------------------------------------------ |
| 匹配if，匹配（     |                                                              |
| `parseE()`         | 翻译逻辑表达式，产生一系列四元式<br />为true，跳转S1<br />为false，跳过then，跳转elseif 后的四元式 |
| 匹配），匹配then   |                                                              |
| `parseS1()`        | 翻译复合语句，产生一系列四元式<br />跳过else，执行下一条语句四元式 |
| 匹配elseif，匹配（ |                                                              |
| `parseE()`         | 翻译逻辑表达式，产生一系列四元式<br />结果为true，跳转S2<br />结果为false，跳过then，跳转else后的四元式 |
| 匹配），匹配then   |                                                              |
| `parseS2()`        | 翻译复合语句，产生一系列四元式<br />跳过else，执行下一条语句四元式 |
| 匹配else           |                                                              |
| `parseS3()`        | 翻译复合语句，产生一系列四元式<br />跳过else，执行下一条语句四元式 |





#### 循环语句while

##### 可改写为if语句和无条件跳转（goto）语句

##### `C->while(E) do S`

| 语法分析          | 语义分析                                                     |
| ----------------- | ------------------------------------------------------------ |
| 匹配while，匹配（ |                                                              |
| `parseE()`        | 翻译逻辑表达式，产生四元式，返回结果<br />结果为true：执行do后的S的四元式<br />结果为false：跳出循环 |
| 匹配），匹配do    |                                                              |
| `parseS()`        | 翻译复合语句，产生四元式<br />无条件返回`parseE()`的第一条四元式 |





### 二、中间代码生成和语义子程序

#### If语句





#### While语句



### 三、目标代码生成

#### 任务

1. 确定目标机器和目标语言
2. 为每条中间代码选择相应的指令(P280)
3. 分配寄存器(P281)
4. runtime存储管理(Ch09)
5. 求值顺序的选择(指令调度P282)





## 第五章 自下而上的语法分析

### 一、引言

#### 思路

+ 基于最左归约的过程，从输入串的第一个二元式开始，向文法的**开始符号**进行归约，只要到达开始符号

#### 自下而上分析的PDA

##### 初始状态：栈顶为#，读头指向开头

##### 基于移进-归约（shift-reduce）方法

+ 移进：顺序遍历二元式
+ 归约：
  + 检查栈顶若干个符号
  + 若能归约则出栈，产生式**左部入栈**
  + 输出选用的产生式编号

##### 识别成功标志：栈内为S#，读头下为#



#### 如何判断栈顶若干符号形成了句柄？

##### 优先分析法（precedence parsing）

+ 定义相邻文法符号之间的优先关系
+ 使句型中，句柄各相邻符号之间具有相同的优先级，且句柄的优先级大于其他相邻符号
+ 核心：构造**算符优先关系表**



##### LR分析法（LR parsing）

+ 基于最左归约，综合考虑三种信息寻找句柄
  + 下推栈中保存的已移进的符号和所处状态
  + 可选择的产生式和归约后可能出现的信息
  + 当前读头下的符号
+ 核心：构造预测分析表



### 二、LR分析

#### 概述

##### 思路

+ 基于最左归约过程，根据三种信息查看预测分析表，寻找句柄
+ 优点：使用文法范围广，能发现并指出错误位置
+ 缺点：构造预测分析表工作量大，容易出错

##### LR分析程序

+ 包括：控制程序（预测分析表）、输入带、输出带、下推栈
+ 一个文法可以对应多个不同的分析表，每种分析表都能识别文法的所有语句，仅强度不同
  + LR(0): 分析能力最弱
  + SLR(1): 改进的LR(0)
  + LR(1): 解决LR(0)的所有问题，分析能力最强，但最复杂
  + LALR(1):对LR(1)弱化改建，降低成泵



#### LR(0)文法

##### LR(0)

+ L: 从左往右扫描输入串
+ R: 基于最右推导的逆过程
+ 0: 构造表时不关注读头下可能的符号
+ 按上述前提为文法构造一张分析表，若表格中每元素有且仅有一个操作，则该文法为LR(0)文法

##### LR(0)文法是上下文无关文法(CFG)的一个子集

+ 绝大多数程序设计语言都能用LR(0)文法表述

##### LR(0)分析的思路

+ 只根据栈内符号和当前状态判断栈顶是否形成句柄

##### 构造分析表的步骤

1. 将文法改成**拓广文法**
2. 写出拓广文法中每条产生式的**项目**
3. 构造识别拓广文法的NFA，以识别出**可归约的活前缀（句柄）**
4. 对NFA进行确定化，获得**LR(0)项目集规范族（即DFA的状态集）**
5. 根据DFA的状态转换图填写预测分析表（Action和GOTO表）

##### 拓广文法（augmented grammar）

+ 添加一个新的开始符, 推导出原来的开始符

##### 项目与活前缀

+ 项目dotted item：右侧某个位置上**多一个点**的产生式

+ 点：概念意义上的分隔符，**和读头下的符号无关**

  + 点的左边：已经入栈的符号，称为**活前缀**
  + 点的右侧第一个符号：下一个希望入栈的符号
  + 即点将产生式分成了若干状态，根据状态确定句柄

  > 例：$S\rarr ABC$,分解为
  >
  > $S\rarr .ABC, 活前缀为\epsilon$
  >
  > $S\rarr A.BC, 活前缀为A$
  >
  > $S\rarr AB.C, 活前缀为AB$
  >
  > $S\rarr ABC., 活前缀为ABC, 此时活前缀形成了句柄，称为可归约的活前缀$

+ 每一个项目对应NFA的一个状态

+ $A\rarr\epsilon的项目$（只有一个状态）：$A\rarr .$



### 三、优先分析

#### 简单优先分析



#### 算符优先分析

