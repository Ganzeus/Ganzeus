# 第一章 计算机系统概述



# 第二章 数据的表示与运算

## 一、定点数

### 定点数的常识

##### 1.有符号数和无符号数的关系

同一个二进制运算，计算机可以将它当做无符号数来运算，也可以当做有符号数来运算。
有无符号只是人为的看待方式不同。
例如加法，不管我们如何看待，CPU运算时就已经包含了两种含义，仅仅是简单的相加

##### 2. 无符号数和有符号数混合加法

+ 只需要保持位数相同后，直接按无符号数的方式直接相加
+ 有符号数高位需补充符号位

例. $无符号8(1000)和-3(1101)相加，结果为(1)0101,高位溢出,但有效位表示的值为5,是正确结果$

$无符号F0000000H+有符号FF12H,FF12H补全后为FFFFFF12H,相加得到EFFFFF12H,也是正确结果$



### 标志位







## 二、浮点数





# 第三章 存储系统

## 一、存储器

### （1）SRAM和DRAM

#### SRAM和DRAM对比

|          | SRAM                        | DRAM                             |
| -------- | --------------------------- | -------------------------------- |
| 存储元件 | 双稳态触发器                | 栅极电容                         |
| 刷新     | 不需要定时刷新              | 需要定时刷新（集中、分散、异步） |
| 读出特性 | 非破坏性读出,读完不需要再生 | 破坏性读出，读完需要再生         |
| 速度     | 快                          | 慢                               |
| 集成度   | 低                          | 高                               |
| 发热     | 大                          | 小                               |
| 成本     | 高                          | 低                               |
| 容量     | 小                          | 大                               |
| 易失性   | 易失（断点信息消失）        | 易失                             |
| 行列地址 | 同时送                      | 分次送（地址线复用）             |
| 用途     | cache/TLB                   | 主存                             |





#### DRAM的刷新

1. 一般2ms一次

2. 一次刷新**一行存储单元**

3. 如何刷新？硬件，读出一行信息后重新充电，耗时一个读写周期（存取周期）

4. 何时刷新？

   集中刷新、分散刷新、异步刷新





### （2）ROM

![image-20220819222125367](../../../img/typora-user-images/image-20220819222125367.png)

##### 注意闪存和固态是ROM不是RAM！！！

+ RAM是易失性存储器，断点不能保存
+ 机械硬盘/光盘既不是RAM也不是ROM，而是直接存取存储器
+ 很多ROM也可以随机存取





### （3）双端口RAM

![image-20220821185703115](../../../img/typora-user-images/image-20220821185703115.png)











## 二、cache

+ cache与主存**以块为单位**进行数据交换

### Cache与主存的映射方式

+ 即哈希的3种方式

#### cache存放的内容

+ **cache中还要建立一张地址映射表（标记阵列），存放主存地址比cache地址多出来的标记位+有效位。**
  **每行都要存相应的标记位和有效位。**
+ 主存地址由块内偏移+（cache组/行号）+标记组成
+ cache**每行**存放的是**数据(一行一块）+标记位+有效位(1bit)+一致性维护位（脏位）+替换算法控制位（计数器）**
+ cache不存放行号！！！！！！

#### 1.直接映射

+ 即直接定址表

+ cache行号=主存块号 mod cache行数

  $cache行号c位(2^c行),主存块号m位(2^m块),则主存的后c位作为映射的cache行号,前m-c位为标记$

   ![image-20220822145501630](../../../img/typora-user-images/image-20220822145501630.png)

##### CPU访存过程

1. 根据要访问的主存地址中间的c位找到cache行号
2. 将对应cache行中存放的地址与其对比：
   1. 标记位相同且有效位为1，则cache命中，CPU直接从cache中存取数据
   2. 标记为不同或有效位为0，则不命中，此时CPU**从主存中**读出该地址的一块信息
      送到cache对应行中，置有效位为1



##### 评价

+ 同余的主存块只能映射到同一个cache行。当访问同余的块时，
  就会引起频繁的调进调出，即使其他行都空闲也没用。因此**cache命中率较低**

#### 2. 全相联映射

+ 即没有映射，随便放
+ **标记就是块号，即指出主存中的哪一块**

 ![](../../../img/typora-user-images/image-20220822161804927.png)

##### CPU访存过程

将主存块号(标记)与**cache的每一行**的标记对比：

1. 有一个标记相等且有效位为1，则命中，CPU直接存取cache数据
2. 没有一个标记相等或有效位为0，则不命中，此时将主存块**复制到cache的任意一个空闲行**中，置有效位为1



##### 评价

1. 只要有空闲cache行，就不会发生冲突，因而**块冲突概率低**
2. 访问主存块的过程是一种**“按内容访问”**的存取方式，即一种**“相联存储器”**，不适合大容量的cache





#### 3. 组相联映射

+ 先分组（模映射），组内随便放
+ **是cache分组，不是主存分组。主存中相邻块对应不同cache组**
+ $cache组号q位(2^q组),则主存每2^q块构成一个组群(组群中每块都在不同的cache组)$
+ 主存块号中的后q位作为cache组号,前m-q位作为标记。
+ **标记字段的含义为主存块位于哪一个组群**
+ n路组相联——一组n行

 ![image-20220822161830783](../../../img/typora-user-images/image-20220822161830783.png)

##### CPU访存过程

1. 根据要访问的主存地址中间q为cache组号，直接找到对应cache组
2. 将对应cache**组中每行**的标记与主存的标记字段对比：
   1. 有一个相等且有效位为1，则命中，CPU直接从cache中存取信息
   2. 都不相等或有效位为0，不命中，此时CPU从主存读出该地址所在的
      一块信息送到**当前cache组的任意一个空闲行**中，置有效位为1



### Cache中主存块替换算法

#### 1. 先进先出

+ 总选择最早装入cache的主存块被替换
+ **不能正确反应程序访问的局部性**
+ 可能产生较大的缺失率

#### 2. 最近最少用LRU

+ 选择近期最少使用的主存块被替换

![image-20220822161908732](../../../img/typora-user-images/image-20220822161908732.png)

+ 最新访问的块号写在最上面，使得**最下面的一块就是最近最久未使用的块**
+ **同一时刻行少的组中的块集合必然是行多组中的块集合的子集**
+ LRU是**栈算法**

##### 用计数器实现LRU

计数器变化规则：（假设cache为4路组相联）

1. 命中时，被访问的行的计数器清零，**比其低的**计数器+1，其余不变
2. 未命中且该组还有空闲行时，则新装入的行的计数器设为0，其余全加1
3. 未命中且该组无空闲行时，计数器为3（**==由(1)可知计数器最多加到3==**）的那一行中的主存块被淘汰。
   新装入的行计数器设为0，其余+1.

#### 3. 最不经常用LFU

+ 替换cache中引用次数最少的块
+ 与LRU类似，但不完全相同
+ **不满足局部性原理**



#### 4. 随机替换

+ 随机选取一个淘汰，与使用情况无关
+ 性能只稍逊于基于使用情况的算法



### cache与主存数据不一致问题（cache写策略）

#### 全写法

+ CPU对cache写命中时，必须把数据同时写入cache和主存。
+ cache中的块被替换时，不需要写回主存，因为写的时候就已经在主存中更新好了。

##### 写缓冲

+ cache和主存之间加一个写缓冲队列(FIFO)
+ 写cache的同时写入写缓冲，**再由写缓冲控制将内容写回主存**
+ 解决速度不匹配的问题
+ 频繁写时，写缓冲会溢出



#### 回写法

+ CPU对cache写命中时，只把数据写入cache。
  只有当此块**被换出时**，才写入主存
+ 为每个cache行设置一个修改位(dirty bit)，修改位为1，说明被修改过。
  只有修改位为1时，替换后才需要写回主存。



#### 写不命中处理方法

##### 写分配法

+ CPU对cache写不命中时，**先将主存块调入cache，再写到cache中**
+ 搭配回写法

##### 非写分配法

+ CPU对cache写不命中时，直接对主存操作，**不管cache**
+ 搭配全写法



## 三、虚拟存储器



## TLB和Cache多级存储系统访存过程

##### 两个任务

1. 找页表项，进行虚拟地址到物理地址的转换（TLB/主存）
   **物理块号+页内偏移量=物理地址**
2. 访问物理块(cache/主存/外存)



##### TLB和Cache

+ TLB存放的是页表项（**即物理块号**）+TLB标记（逻辑块号）
  **页表项中只有物理块号，因为页号作为下标，不占空间；**
  **而TLB中无法通过下标知道物理块来自哪个逻辑块，因此还要存放逻辑块号**
+ cache存放的是物理块
+ 两者都是高速缓存（SRAM）



##### CPU访存过程

![image-20220823205523728](../../../img/typora-user-images/image-20220823205523728.png)



# 第四章 指令系统



## 寻址方式

+ 分为指令寻址和数据寻址

### 指令寻址



### 数据寻址









## 三、程序的机器级表示

### 汇编语言









## 四、CISC和RISC











# 第五章 CPU













# 第六章 总线











# 第七章 I/O

## I/O接口

#### 基本结构与工作原理

![image-20220811185022234](../../../img/typora-user-images/image-20220811185022234.png)

+ **I/O端口**：I/O接口中**可被CPU直接访问的寄存器**，作用是**协调CPU与设备间速度的不匹配**
+ 发命令：发送**命令字**到I/O控制寄存器，获得设备或I/O控制器的状态信息
+ 读状态：从状态寄存器读**状态字**，获得设备或I/O控制器的状态信息
+ 读/写数据：从数据缓冲寄存器发送或读取数据，完成主机与外设的数据交换

#### I/O端口

> **I/O端口**：I/O接口中**可被CPU直接访问的寄存器**，作用是**协调CPU与设备间速度的不匹配**

![image-20220812060941662](../../../img/typora-user-images/image-20220812060941662.png)

#### I/O编址方式

![image-20220812061005268](../../../img/typora-user-images/image-20220812061005268.png)



## I/O方式

### 程序查询方式

#### 三种方式简介

![image-20220812045450262](../../../img/typora-user-images/image-20220812045450262.png)

#### 特点

+ 主要特点：CPU**“踏步”等待**，与I/O设备**串行**工作
+ 优点：接口设计简单，设备量少
+ 缺点：CPU需要花大量时间查询和等待，效率极低
+ 不适合慢速设备（慢速设备查询次数非常多）

#### 两种查询方式

+ 独占查询：CPU 100%时间都在查询I/O状态，完全串行
+ 定时查询：保证数据不丢失情况下，每隔一段时间就查询一次。
  查询间隔内CPU可以执行其他程序



### 程序中断方式

#### 中断判优

##### 实现方法

+ 中断判优即可通过硬件实现，也可用软件实现
  软件实现慢

##### 一般的优先级设置

1. 不可屏蔽中断>内部异常>可屏蔽中断
   不可屏蔽中断在关中断下也会被响应
2. 内部异常中：硬件故障>软件中断
3. DMA请求>I/O设备的中断请求
4. 高速设备>低速设备
5. 输入设备>输出设备
6. 实时设备>普通设备

#### 多重中断

##### 满足的条件

1. 保护现场和屏蔽字后需要开中断
   不能再之前就开中断，否则保护现场会失败
2. 保存中断处理优先级

##### 中断屏蔽字

+ 每个中断源对其他所有中断源都有一位屏蔽字

  即形成一个矩阵，每个中断源占一行

+ 1表示屏蔽该中断源的中断，0表示不屏蔽

![image-20220812040219949](../../../img/typora-user-images/image-20220812040219949.png)

+ 优先级D>A>C>B
+ 横向看：比自己高级的中断源都置0
+ 屏蔽字全1表示该行的中断源是最高级
+ 1越多越高级



#### 中断流程

![image-20220812043137815](../../../img/typora-user-images/image-20220812043137815.png)

+ 中断过程分为中断隐指令和中断服务程序，中断隐指令由硬件自动完成
+ 断点：用指令无法直接读取程序计数器PC和程序状态字寄存器PSWR等的内容
+ 现场：用户可见的工作寄存器的内容

##### 中断隐指令（中断响应）

1. 关中断
2. 保存断点
3. 中断服务程序寻址

##### 中断服务

4. **进入中断服务程序后**首先要保存现场和屏蔽字
5. 开中断：允许高级中断请求得到响应
6. 执行中断服务程序：中断的目的
7. 关中断：恢复现场和屏蔽字时不能被中断
8. 恢复现场和屏蔽字
9. 开中断，中断返回

##### I/O流程

1. CPU执行到I/O指令(`scanf`或`printf`等)时，启动外设**准备数据**
2. 外设准备完后，向CPU发出中断请求
3. CPU在指令k执行完后响应该中断请求
   先中断隐指令（硬件自动），再中断服务程序
4. 中断服务程序完成后，**外设可以继续工作,准备下一次数据**
5. 中断返回，CPU执行指令k+1

### DMA方式

![image-20220812044244222](../../../img/typora-user-images/image-20220812044244222.png)

#### DMA控制器构造

![image-20220812044323473](../../../img/typora-user-images/image-20220812044323473.png)

#### DMA特点

![image-20220812044601249](../../../img/typora-user-images/image-20220812044601249.png)

+ **DMA请求>所有外中断（不可屏蔽、可屏蔽）**
+ DMA数据传送**完全由硬件实现**



#### DMA与中断方式对比

![image-20220812044449340](../../../img/typora-user-images/image-20220812044449340.png)



#### DMA工作流程

1. 外设向DMA控制器发出**DMA请求**，DMA控制器向CPU发出**总线请求**
2. CPU在当前**机器周期结束后**相应DMA的总线请求，让出总线控制权
3. CPU预处理
4. 数据传送：完全由硬件完成，CPU继续执行原来程序
5. 后处理：DMA数据传送完成后，向CPU申请中断，转入**中断服务程序**
