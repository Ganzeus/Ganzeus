#### CPU 部分

##### MAR位数

1. 算出主存存储单元个数
2. 位数即为$log_2{单元数}$

+ 与指令格式无关

##### 最多可定义多少条指令（多少种操作）

+ 先得到指令操作码op的位数
+ 最多指令数即为$2^{op}$



##### ALU宽度

+ 即字长，一次运算的二进制位数



##### 流水线“按序发射、按需完成”

+ 即不同指令的流水线各功能段严格按顺序进行
+ 前一条指令取指完后，后一条指令才能取指
+ 前一条指令一定比后一条指令先执行完
+ 例：五段流水线IF、ID、EX、M、WB
  **后一条指令的IF必须在前一条指令的IF执行完后进行（即使前一条指令阻塞，后一条指令也要等待）**
  **即==后指令IF最快只能与前指令ID并行执行==**



##### 总线带宽

+ 即总线每秒的传输速率
+ ==与传输的信息（地址/数据）无关，不论什么数据都算在总线带宽里==



#### 内存部分

##### TLB访问次数

> 例如，访问数组A[0]~A[999]，初始A不在主存中，A的所有元素均在同一页块

1. 第一次访问A[0]时，==先查TLB一次==，产生缺页，==调页后先存入TLB，再从TLB中读取A[0]==。
   即访问A[0]已经访问了2次TLB
2. 后999个元素都会访问一次TLB
3. 因此一共访问1001次TLB



##### 页表项地址

+ 给定逻辑地址后，就能知道页号
+ 而进程逻辑地址一定从0开始，因此给定页表项起始地址后，就能通过页号找到所有页表项的地址

##### 知道页号就能知道该页的起始物理地址！

+ 由于分页管理中主存地址空间是按页为单位划分的，因此==每一页的起始物理地址的偏移量一定是0==

##### cache总容量位数

1. 算行数
2. 每行存放内容：
   1. 数据
   2. 标记tag
   3. 有效位（1）
   4. dirty bit（1）——==回写法==才有
   5. LRU位（替换算法控制位）——看题目要求
3. 总容量位数为每行位数*行数



##### 算组号、页号、标记等

+ ==注意题目给的是虚拟块号还是完整虚拟地址！！！==



##### 算指令虚拟地址

+ ==是十六进制加法！！！==
+ 例：25+5=2A（不是30！）



#### 磁盘部分

##### 读取一个随机扇区的时间

+ ==两个部分：寻道时间+读取时间==
+ 寻道时间：**即转半圈的时间（==不是半个扇区！！！==）**
+ 读取时间：转一个扇区的时间



##### 磁盘物理地址

+ 格式为==（柱面号，盘面号，扇区号）==

+ 柱面号=磁道号，指在哪一圈
+ 盘面号=磁头号，指在那一层
