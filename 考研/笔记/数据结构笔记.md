数据结构笔记by以禾

****

## 一、线性表

### 链表

#### 1、单链表

##### 链表的插入：

+ 需要知道插入位置的前驱结点（**从表头顺序遍历**）
+ 先修改要插入的结点的指针
+ 再修改前驱结点的指针

##### 链表的删除：

+ 要知道删除结点的前驱结点（**从表头顺序遍历**）
+ 只需要修改前驱结点的指针
+ 最后delete/free

**已知一个结点，只能对后继结点进行操作（插入/删除）**



#### 2、双链表

##### 插入和删除

+ 操作与单链表类似，但需要多操作两个指针

**双链表有前驱指针，因此可以还对已知的当前结点进行插入删除操作**

+ 双链表+尾指针：在尾部结点操作不需要遍历



#### 3、循环链表

循环链表在任何位置插入和删除都是等价的，无需判断是否在表尾。即**循环链表有头指针等价于有尾指针**。

循环链表尾指针是头指针的前驱



****

## 二、栈、队列和数组

### 1、栈

#### 顺序栈

**卡特兰（Catalan）数**：n个不同元素进栈，出栈不同排列的个数为$\frac{1}{n+1}C^n_{2n}$

##### 共享栈

+ 栈满条件：**两个栈顶指针相邻**（`top2-top1==1`）
+ 好处：节省存储空间，降低发生上溢的可能
+ 对存取时间无影响

#### 链栈

##### 注意点

+ 单链表实现

+ **所有操作在表头进行**，即next指向栈底方向
+ top是一个指针（不是结点），指向栈顶（链表第一个结点）。

##### 操作

1. 向栈顶指针为top插入结点x

```C++
x->next = top;	// 先修改要插入的结点指针
top = x;		// 保持top指向栈顶
```

2. Pop操作，x存放出栈元素

```C++
x = top->data;	// 获得栈顶元素
top = top->next;	// 修改top指针（指向下一个结点）
```



### 2、队列

#### 顺序存储

+ 初始化（队空条件）：`Q.front == Q.rear == 0 `

+ 进队时队尾指针向后移动，出队时队首指针向后移动，因此可能会出现两个指针挤在数组末尾，造成**上溢**，

  这种溢出不是真正的溢出，数组中还有存放空间，因此成为**“假溢出”**

+ **队尾入队，队头出队**

#### 循环队列

+ 解决了假溢出的弊端
+ 初始化（队空条件）：`Q.front == Q.rear == 0`
+ 队首指针进1：`Q.front = (Q.front + 1) % MaxSize`
+ 队尾指针进1：`Q.rear = (Q.rear + 1) % MaxSize `
+ **队列长度**：`(Q.rear + MaxSize - Q.front) % MaxSize`
+ 出队或入队指针都按顺时针方向进1

##### 判断队满

1. 牺牲一个单元：

   **队头指针在队尾指针的下一个位置作为队满的标志**，即`(Q.rear + 1) % MaxSize == Q.front`

2. 增加元素个数的数据成员：

   `Q.size == MaxSize`时队满，此时`Q.front == Q.rear`

3. 增设tag成员：

   tag==0时：若因删除导致`Q.front == Q.rear`, 为队空

   tag==1时; 若因插入导致`Q.front == Q.rear`, 为队满



#### 链式队列

+ 判空：`Q.front == NULL && Q.rear == NULL`
+ 初始化两个指针都指向头结点
+ **front始终指向头结点，rear始终指向最后一个结点**



#### 双端队列

+ 两边都能入队出队
+ 输出受限：有一端只能进
+ 输入受限：有一端只能出





## 三、树

### 1、基本概念

#### 树

+ 结点的度数为结点的孩子个数
+ 树的结点数等于所有结点的度数和+1
+ 树根为第1层
+ 树的深度自顶向下，高度自底向上
+ 度为m的树（m>1)表示树高>1
+ 度为m的树第i层最多有$m^{i-1}$个结点
+ 高为h的m叉树至多有$\sum^{h-1}_{i=0}{m^i} = \frac{m^h-1}{m-1}$



#### 二叉树

+ 二叉树 n0 = n2 + 1

+ 第 i 层最多$2^{i-1}$个结点

+ h层的二叉树最多有$2^{i}-1$个结点

+ 二叉树结点个数为偶数，则n1必为奇数(n1 = n - 2n2 - 1)

+ **完全二叉树n1只能取0或1**

+ 完全二叉树有n个结点，则最后一个有孩子的结点下标为[n/2],其余全是叶子

+ **n个结点的二叉树有n+1个空指针**

  n个结点，总度数为n-1,总指针数为2n，则空指针数为$2n-(n-1) = n+1$





### 2、二叉树遍历

#### 非递归遍历

##### 中序

1. 沿着根的左孩子，依次入栈，直到左孩子为空，说明找到了可以输出的结点。
2. 栈顶元素出栈并访问：若右孩子为空，继续执行2；否则对右子树执行1

```C++
vector<int> path;
void inOrder(node* root) {      // 非递归中序
    stack<node*> stk;
    node* p = root;     // p为遍历指针
    while(!stk.empty() || p) {  // p空且栈空时退出
        if(p) { // 一路向左遍历并入栈
            stk.push(p);
            p = p->lchild;
        }else { // 当前结点为空，则应该访问栈顶元素（当前的父结点），再遍历父结点的右子树
            p = stk.top();
            stk.pop();
            path.push_back(p->data);
            p = p->rchild;
        }
    }
}
```



##### 先序

```C++
vector<int> path;
void preOrder(node* root) {     // 非递归先序
    stack<node*> stk;
    node* p = root;     // p为遍历指针
    while(!stk.empty() || p) {  // p空且栈空时退出
        if(p) { // 一路向左遍历
            path.push_back(p->data);    // 先访问（当前子树的根结点）
            stk.push(p);          // 再入栈
            p = p->lchild;  // 继续向左
        }else { // 当前结点为空，则回头遍历栈顶结点的右子树
            p = stk.top();  // 栈顶结点为当前结点的父结点
            stk.pop();
            p = p->rchild;  // 遍历右子树
        }
    }
}
```



#### 一些结论

+ 先序和后序正好相反$\Lrarr$高度等于结点数$\Lrarr$只有一个叶子
+ 两个结点前序为XY，后序为YX，则X是Y的祖先



### 3、线索二叉树

+ 若无左子树，则`lchild`指向前驱结点；若无右子树，则`rchild`指向后继结点
+ 增加两个标志位`ltag`和`rtag`，为0表示由左(右)子树
+ **二叉树的线索化**：将二叉链表的空指针**改为**指向前驱或后驱的线索
+ **线索二叉树是加上线索后的链表结构，是一种物理结构**
+ **无法通过线索直接找到的**：先序前驱，后序后继（**需要知道双亲结点，而线索二叉树没有存放双亲的指针）





### 4、树和森林

#### 树、森林与二叉树的转换

##### 树转二叉树

+ ”孩子兄弟表示法“：**左孩子右兄弟**



##### 二叉树转森林

1. 将根及左子树视为第一棵树，右链断开
2. 剩下来的二叉树按同样方法
3. 直到最后**只剩一棵没有右子树的二叉树**为止



#### 树和森林的遍历

**相当于转换为二叉树后再遍历**



##### 树先序：

1. 访问根结点
2. 依次遍历根结点的每棵子树（先根后子树）

##### 树后序：

1. 依次遍历根结点的每棵子树
2. 访问根结点
3. **相当于转换为二叉树后的中序遍历**

##### 森林先序（递归定义）：

1. 访问第一棵树的根
2. 先序遍历第一棵树根的子树森林
3. 同样方法遍历剩下的森林

##### 森林中序（递归定义）：

1. 中序遍历第一棵树根的子树森林
2. 访问第一棵树根
3. 同样方法遍历剩下的森林



##### 与二叉树遍历的对应

| 树   | 森林 | 二叉树 |
| ---- | ---- | ------ |
| 先序 | 先序 | 先序   |
| 后序 | 中序 | 中序   |



#### 一些结论

+ 森林转二叉树后，由二叉树判断树的个数：**只要数右上方的结点数**
+ **一棵树也可叫森林！！**
+ 森林由n个非叶结点，转换为二叉树后会出现**n个叶子**，加上在最后一棵树的根结点，共有**n+1**个无右子树的结点
+ 森林叶子个数等于转为二叉树后无左孩子的结点个数
+ 森林树的个数等于**结点数减边数**（连通分支数）



### 5、哈夫曼树与并查集

#### 结论

+ n个叶子的哈夫曼树有n-1个非叶结点
+ 结点的带权路径长度是**由根到结点经过的边数**乘该结点权值；树的带权路径长度是**所有叶结点**带权路径长度之和
+ **哈夫曼树只有度为0和2的结点**
+ 并查集是**双亲表示法**存储的树



## 四、图

### 1、基本概念

#### 说法

+ **图至少有一个顶点，可以没有边**

+ **极大连通分量：子图顶点可以少，边不能少**
+ **极小连通子图：保证子图连通，且边最少**
+ **连通图的生成树是包含图中全部顶点的一个极小连通子图**

+ 简单路径：顶点不重复出现的路径
+ 简单回路：除了第一个和最后一个顶点相同外，其余顶点不重复的路径

#### 无向图

+ **所有顶点度数和等于边数的两倍**（每条边关联两个顶点）

+ 完全图：$\frac{n(n-1)}{2}$条边（每个点的度为n-1）

+ 无向图的**极大连通分量称为连通子图**

+ 边数$<n$，一定是非连通图

+ **非连通图最多$\frac{(n-1)(n-2)}{2} +1$条边**（n-1个顶点的完全图+一个孤立顶点）



#### 有向图

+ **所有顶点的入度和=所有顶点出度和=边数**（每条有向边都有一个起点和终点）
+ 有向完全图：$n(n-1)$条边（每个顶点出度和入度均为n-1)
+ **有向图讨论强连通，无向图讨论连通**
+ **强连通图最少n条边**（形成一个环）



### 2、图的存储

#### 邻接矩阵

+ 对于无向图，每行或每列非零元素的个数为对应顶点的度
+ 对于有向图，每行为顶点的出度，每列为顶点的入度
+ 邻接矩阵为A, $A^n$的元素$A^n[i][j$为$i到j长度为n的路径数目$

#### 邻接表

+ 无向图邻接表每条边存放两次（即边表个数一定是偶数）



### 3、图的遍历

#### 1.DFS

+ 空间复杂度$O(n)$
+ 时间复杂度：邻接矩阵$O(n^2)$，邻接表$O(n+e)$
+ **DFS遍历DAG，退出递归时输出顶点，最后得到的序列是逆拓扑有序序列**

##### DFS生成树

+ DFS序列对应该生成树的先序遍历
+ 显然不唯一
+ **树高可长可短**



#### 2.BFS

+ 空间复杂度$O(n)$
+ 时间复杂度：邻接矩阵$O(n^2)$，邻接表$O(n+e)$

##### BFS生成树

+ 每个结点的层序构造的一棵树
+ BFS序列对应该生成树的层序遍历
+ 生成树不唯一，但**树高唯一，是该图所有生成树中树高最短的（树根到其他结点的路径都是最短的）**
+ **BFS生成树高度$\le$DFS生成树高度**





### 4、最短路

#### Dijkstra

+ **每次循环选中的顶点一定是当前距顶点最短的一个**，即顺序是d数组的递增序列



### 5、最小生成树

**含有图中所有顶点，且边权值和最小**

#### 1.Prim

与Dijkstra思想几乎相同

##### 与Dijkstra区别：

+ Dijkstra找到未访问的最短距离的点后，优化从该点可以到达且能使其与起点距离更短的点（**`d[i]`表示i与起点的最短距离**）
+ Prim找到不在生成树的最短距离的点后，优化从该点可以到达且能使其与生成树中任意一点距离更短的点（**`d[i]`表示i与生成树的最短距离**）
+ **被优化的结点不算已访问**，每次循环只记录一个已访问（即与生成树最短的一个结点）

##### 和Dijkstra复杂度都是$O(n^2)$

#### 2.Kruskal

边集数组+并查集

算法：

1. 对所有边按边权排序
2. 对于每条边，测试两端点是否在同一集合中，若不在
   1. 合并两条边
   2. `ans += 当前边权`
   3. 最小生成树当前边数++
   4. **当边数等于顶点数-1时退出循环**

**复杂度$O(mlogm)$**



### 6、关键路径（即DAG最长路）

**AOV（Activity On Vertex）**：用顶点表示活动，有向边边表示优先级

**AOE(Activity On Edge）**：边表示活动，边权表示活动进行的时间，顶点表示活动完成的事件

**AOE网中的最长路径称为关键路径，关键路径上的活动称为关键活动**



#### 1. 拓扑排序（DAG)

##### 算法：

队列+入度数组

1. 将所有入度为0的顶点入队
2. 循环（队列为空退出）：
   1. 取队首，对于从它出发的所有边，将其邻接点入度-1
   2. 邻接点入度为0时入队
3. **判断是否是DAG**：队列为空时**入过队的结点数为n**，则是DAG，否则不是

**用邻接表存储，复杂度$O(n+m)$**

#### 2.关键路径的四个参量

​			$事件v_i ---活动a_r --\rarr事件v_j$

##### 1. 事件$v_k$（顶点）的最早发生时间(ve)

+ 指从源点$v$到$v_k$的最长路径长度
+ $v_k$的最早发生时间决定了从$v_k$开始的活动（边）能开工的最早时间

+ $ve[源点]=0$

+ 从前往后算（**拓扑序**）：（对于每个点，可以计算所有后继节点的ve）

  $ve[j] = max\{ve[i_1] + length[r_1], \\ \quad ve[i_2] + length[r_2],\\...,\\ \quad ve[i_k]+length[r_k]\}$

  **结点j的ve是所有前驱结点的最长时间**

+ 拓扑排序时可以顺便完成ve的计算

  

##### 2. 事件的最迟发生时间(vl)

+ 要保证后继结点在其最迟发生事件能完成

+ $vl[汇点] = ve[汇点]$

+ 从后往前算（**逆拓扑序**）：

  $vl[i] = min\{vl[j_1]-length[r_1], \\ \quad vl[j_2]-length[r_2],\\ ..., \\ \quad vl[j_k]-length[r_k\}$

+ 拓扑排序序列用站存放，则可以依次出栈来用所有后继结点计算栈顶结点的vl



##### 3. 活动$a_r$（边）的最早开始时间(e)

+ 即这条边的起点（事件）的最早发生时间
+ `e[r] = ve[i]`

##### 4. 活动的最迟开始时间(l)

+ 即这条边的终点（事件）的最迟发生时间-当前活动的耗时
+ `l[r] = vl[j] - length[r]`



#### 4.关键路径

+ **最早开始时间==最迟开始时间的活动**是关键活动`e[r]==l[r]`

##### 求关键路径的步骤

1. 从源点开始，计算所有结点的ve
2. 从汇点回头，计算所有结点的vl
3. 求各边（活动）的e和l
4. 找到e==l的关键活动



### 7、重要结论

1. **拓扑序列唯一并不能唯一确定该图**
2. **有序拓扑序列的图的邻接矩阵是三角矩阵**（有序是人为的）
3. **只有缩短才会导致出现不同的关键路径**（缩短的不是所有关键路径上的公共边）
4. **DAG最长路一定是关键路径**，因此画好图后直接找最长路即可





## 五、查找

### 1、顺序查找和二分

#### 顺序查找

##### 一般线性表

1. **查找成功的平均查找长度$ASL = \sum^n_{i=1}\frac{1}{n}i = \frac{n+1}{2}$**
2. 查找不成功：$ASL_{不成功} = n+1$

##### 有序表

1. **查找失败(有序表）的平均查找长度$ASL_{成功} = \sum_{i=1}^n \frac{1}{n}(l_j+1) = \frac{n}{2} + \frac{n}{n+1},\quad l_j是判定数中第j个失败节点所在层数$**

   **失败结点也算一次比较！**

##### ASL与是否有序无关！！！



#### 二分

##### 模板

```C++
int BinarySearch(vector<int>& a, int k) {
    int l = 0, r = a.size() - 1;
    while(l <= r) {
        int mid = l + (r-l)/2;
        if(k < a[mid]) {
            r = mid-1;
        }else if(k > a[mid]) {
            l = mid + 1;
        }else return mid;   // 找到k，返回下标
    }
    return -1;  // 没找到
}

int lowerBound(vector<int>& a, int k) { // 大于等于k的最小下标
    int l = 0, r = a.size() - 1;
    while(l < r) {
        int mid = l + (r-l)/2;
        if(a[mid] >= k) r = mid;    // 中点大于等于k，可能就是此处，往左找
        else l = mid + 1;
    }
    return l;   // l==r说明找到
}

int upperBound(vector<int>& a, int k) { // 大于k的最小下标
    int l = 0, r = a.size() - 1;
    while(l < r) {
        int mid = l + (r-l)/2;
        if(a[mid] <= k) l = mid + 1;    // 中点小于等于k，往右找
        else r = mid;   // 中点大于k，可能就是此处
    }
    return l;
}
```



##### 一些结论

+ 判定树是一颗AVL
+ 仅适用于顺序存储，不适合链式存储（**需要随机存取特性**）
+ **ASL = $\frac{1}{n}(1\times1 + 2\times2 + ... + h \times 2^{h-1}) = \frac{n+1}{n}log_2(n+1)-1 \approx log_2(n+1)-1$**
+ **二分判定树高度为$log_2(n+1)$,(向上取整）**
+ **二分时失败结点不算比较次数！！因此查找不存在的元素比较次数最多是树高（$log_2(b+1)向上取整$**
+ **查找成功和查找失败的最多比较次数相同**
+ mid既可以向上取整，也可以向下取整，但必须统一（**用来判断判定树是否符合条件**）



#### 分块查找(索引顺序结构)

块内无序，块间有序

先二分(或顺序)块，在顺序查找块内

##### ASL(长度为n，有b块，每块s个记录)

1. 均采用顺序查找：$ASL=\frac{b+1}{2} + \frac{s+1}{2}$	

   **当块个数为`sqrt(n)`时，ASL取到最小值`sqrt(n)+1`**

2. 块间二分：$ASL = log_2(b+1)+\frac{s+1}2，(向上取整)$





### 2、树型查找

#### BST

##### 模板

```C++
struct node {
    int data;
    node* l, * r;
};
node* newNode(int x) {
    node* Node = new node;
    Node->data = x;
    Node->l = Node->r = nullptr;
    return Node;
}
void insert(node*& root, int x) {
    if(root == nullptr) {
        root = newNode(x);
        return;
    }
    if(x <= root->data) insert(root->l, x);
    else insert(root->r, x);
}

void search(node* root, int x) {
    if(root == nullptr) return;
    if(x == root->data) cout << x << endl;
    else if(x < root->data) search(root->l, x);
    else search(root->r, x);
}
```

+ 插入顺序不同会形成不同的BST，平均查找长度会随之改变
+ $ASL_{min} = \log_2n,\quad ASL_{max} = n$
+ **BST中序是递增序列**（左小右大）

##### BST的删除

1. 叶结点直接删除
2. 有一棵子树：**整个子树**替换要删除的结点
3. 有两棵子树：用前驱或后继替换要删除的结点，**再递归删除替换的结点**（是上面两种情况之一）

##### BST先删除再插入相同结点

+ 若是叶结点，则前后BST不变
+ 若**不是叶结点**，则**前后BST必改变**（一定会存在子树的替换，而插入后没有替换操作）

##### n个结点的BST有n+1个失败结点（null）

+ n个数据分成n+1个区间
+ **对所有二叉树成立**



#### AVL

##### 模板

```C++
struct node {
    int data;   // 结点权值
    int height; // 当前子树高度
    node* lchild, * rchild;
};
int getHeight(node* root) { // 计算当前子树高度
    if(root == nullptr) return 0;   // 空子树高度为0
    else return root->height;
}
int getBF(node* root) {     // 计算平衡因子
    return getHeight(root->lchild) - getHeight(root->rchild);   // 左子树高-右子树高
}
void updateHeight(node* root) { // 更新当前子树高度
    root->height = max(getHeight(root->lchild), getHeight(root->rchild)) + 1;   // 左右子树高度较大值+1
}

void search(node* root, int x) {   // AVL的搜索（与BST完全相同）
    if(root == nullptr) return;
    if(root->data == x) cout << x << endl;
    else if(x < root->data) search(root->lchild, x);
    else search(root->rchild, x);
}
node* newNode(int x) {   // 新建权值为x的结点
    node* root = new node;
    root->data = x;
    root->height = 1;   // 单个结点的高度为1
    root->lchild = root->rchild = nullptr;
    return root;
}
void L(node*& root) {    // 左旋
    node* tmp = root->rchild;   // 保存最终的根结点，后面紧接着修改
    root->rchild = tmp->lchild; 
    tmp->lchild = root;         
    updateHeight(root);         // 修改根结点之前要更新高度
    updateHeight(tmp);
    root = tmp;
}
void R(node*& root) {    // 右旋（与左旋操作完全对应），只要把l改r
    node* tmp = root->lchild;
    root->lchild = tmp->rchild;
    tmp->rchild = root;
    updateHeight(root);
    updateHeight(tmp);
    root = tmp;
}
void insert(node*& root, int x) {    // AVL的插入
    if(root == nullptr) {
        root = newNode(x);
        return;
    }
    if(x < root->data) {    // 欲插结点比当前结点小，往左插
        insert(root->lchild, x);
        updateHeight(root);     // 更新树高
        if(getBF(root) == 2) {  // 若插入后当前子树不平衡
            if(getBF(root->lchild) == 1) {  // LL型
                R(root);
            }else if(getBF(root->lchild) == -1) {   // LR型
                L(root->lchild);
                R(root);
            }
        }
    }else { // 欲插结点比当前结点大，往右插
        insert(root->rchild, x);
        updateHeight(root);
        if(getBF(root) == -2) { // 插入后当前子树不平衡
            if(getBF(root->rchild) == -1) { // RR型
                L(root);
            }else if(getBF(root->rchild) == 1) {    // RL型
                R(root->rchild);
                L(root);
            }
        }
    }
}
node* Create(int data[], int n) {   // 建AVL, 返回根结点
    node* root = nullptr;
    for(int i = 0; i < n; i++) {
        insert(root, data[i]);
    }
    return root;
}
```

+ AVL是BST
+ AVL的最大深度为$\log_2{n}$，$ASL = \log_2(n)$

##### AVL的最少结点数

$n_h$表示h层AVL的最少结点数

+ $n_0 = 0, n_1 = 1, n_2 = 2, n_3 = 4, n_4 = 7, n_5 = 12, n_6 = 20$
+ **$n_h = n_{h-1} + n_{h-2} + 1$**
+ **用于判断n个结点AVL的最大深度或h层AVL的最少结点数**
+ **结点最少时所有非叶子结点平衡因子均为1**



##### AVL的删除

1. 用BST的删除方法
2. 向上回溯至第一个不平衡的结点，进行旋转调整
3. 若依旧不平衡则一直回溯，直到根结点

##### AVL先删除再插入相同结点

+ **不论是叶结点还是非叶结点**，前后AVL**都可能不同**（删除或插入后可能不平衡，需要旋转）
+ 若删除和插入后**都没有导致AVL的旋转，则此时与BST的结论相同**







#### 红黑树

##### 定义

1. 每个结点不是黑就是红
2. **根是黑**
3. 叶子结点（**null结点**）是黑
4. 不存在两个相邻的红结点（**可以有相邻的黑**）
5. 对**每个结点**，从该结点到任一叶结点的简单路径上，黑的数量相同

##### 注意

+ 红黑树是BST，**不是AVL！！！**

##### 引入结点的"黑高"：

+ 从某结点出发到达任一叶结点(null)路径上的黑结点总数（**不含该结点**）



##### PAT1135 Is It A Red_Black Tree

```C++
```



##### 红黑树的性质

1. **从根结点到叶结点的最长路径不大于最短路径的两倍**（最长路径即红与黑数量相等）
2. n个内部结点的红黑树的高度$h\le2\log_2(n+1)$，从而红黑树查找复杂度为$O(\log{n})$

+ 高度为h的红黑树结点最少的情况：**全是黑结点的满二叉树，结点数为$2^h-1$**(即根结点黑高为h)

  若红黑树总高度h（含叶），则根结点的**黑高$\ge \frac{h}{2}$(红黑交叉）**，即内部节点数$n\ge 2^{\frac{h}{2}}-1$

  从而有n个内部结点的红黑树，**最高h = $2log_2(n+1)$**

+ **红黑树插入删除查找复杂度和AVL相同**

+ **任意结点的左右子树高度，相差不超过两倍**

##### 红黑树的插入

###### 1. 先查找，确定插入位置（同BST），插入新结点

######2. 新结点是根——染成黑色

###### 3. 新结点**不是根——染成红色**

+ 插入后满足红黑树定义，则插入结束

+ 插入后不满足红黑树，需要调整（**看叔结点（父结点兄弟）的颜色**）

  + 叔是黑：**旋转+染色（旋转同AVL**）

    + LL:右旋，父换爷+染色
    + RR:左旋，父换爷+染色
    + LR:左右双旋，儿换爷+染色
    + RL:右左双旋，儿换爷+染色

    **单旋父换爷，双旋儿换爷**

  + 叔是红：**染色+变新**

    + 叔父爷染色，爷变新结点（将爷视为新插入的结点，执行上述操作）

  + **上述染色表示红黑反转，且只染提到的结点（二、父、叔、爷）**
  
  注：**插入后只需要判断是否出现连续两个红，不需要判断平衡**
  
  



### 3、B树和B+树

#### B树（磁盘）

##### 定义

1. B树的阶即每个孩子指针个数
2. m阶B树每个结点至多m个孩子，m-1个数据域
3. 若根结点不是终端结点，则至少有两棵子树（要满足左右等高）
4. **除根结点的所有非叶结点至少有[m/2]棵子树，[m\2]-1个数据域**（向上取整）
5. 结点还有一个数据域表示结点中非空数据域的个数
6. 所有**叶结点（null）**都在同一层（**最后一层**）

```C++
struct node {
    vector<int> data;   
    node* children[5];  // 5阶B树
    // n = data.size(); 
}
```

+ **B树所有结点的平衡因子均为0（左右子树等高）**
+ 最底层的非空结点称为**终端结点**
+ B树又称多路平衡查找树
+ 除根结点外，每个结点关键字个数$[m/2]-1\le n \le m-1$（根结点可以只有一个关键字）





##### B树的高度

n个关键字的m阶B树，

**最小高度：**每个结点都是满的（m-1个数据域，m个子树）

+ $第一层1个结点，第二层2个结点......第h层m^{h-1}个结点$
+ 总数据域个数：$(m-1)(1+m+m^2+...+m^{h-1}) = m^h-1$
+ **即，高为h的m阶B树，总结点树最多有$m^h-1个,n\le m^h-1$**
+ **$h \ge \log_m(n+1)$**



**最大高度：**每个结点子树尽可能少

**方法一**

+ 根结点两个分叉，其他结点[m/2]个分叉
+ $第一层1个结点，第二层2，第三层2\times[m/2],第四层2\times[m/2]^2,...第h层2\times[m/2]^{h-2}$
+ 根结点一个关键字，其他结点[m/2]-1个关键字
+ 总关键字数：$1\times1+([m/2]-1)(2 + 2[m/2] + 2[m/2]^2 + ... + 2[m/2]^{h-2)} = 1+2([m/2]^{h-1}-1)$
+ **即h层m阶B树至少有$1+2([m/2]^{h-1}-1)$个关键字**（若关键字少于这个数，层数必然达不到h层）
+ $n\ge1+2([m/2]^{h-1}-1),\quad h\le \log_{[m/2]}\frac{n+1}{2}+1$



**方法二**

+ $h+1层有2([m/2])^{h-1}个叶子结点$（**此时B树含有最少的叶子结点）**
+ **n个关键字必有也只能有n+1个叶子结点（n个数分成n+1个区间）, 对所有BST成立**
+ 因此$n+1 \ge 2([m/2])^{h-1},即h\le \log_{[m/2]}\frac{n+1}{2}+1$

**总结：$\log_m(n+1) \le h \le \log_{[m/2]}\frac{n+1}{2}+1$**





##### B树的查找

+ 同BST
+ 遇到叶结点（null）说明查找失败





##### B树的插入

+ **新元素一定是插入到最底层（终端结点）**
+ 用查找来确定插入位置

+ **插入后导致结点关键字个数溢出，此时要从中间位置[m/2]将关键字分成两部分**

  **左边放在当前结点，右边放在新节点，中间的元素插入父结点**

+ 若最后导致根结点关键字个数溢出，则**中间元素成为新的根结点，B树高度+1**



##### B树的删除

+ 终端结点，直接删除；不是终端结点，用前驱或后继替换，**转换为删除终端结点**

  （**每个结点的前驱或后继都在最底层的终端节点上**）

**删除后导致结点关键字个数低于下限，要进行调整：**

1. **向兄弟借**：

   用父结点替换被删除的结点，再用兄弟结点替换父结点（父结点和兄弟结点都在同一侧）

   ***这种情况父结点关键字个数不变，兄弟结点关键字个数-1，依然符合B树定义***

2. **兄弟不够借：**（即左右两兄弟的结点数都正好是下限）

   **将当前结点和一个兄弟以及夹着的父结点一起合并，合并到当前这层**

   （当前结点[m/2]-1，兄弟结点[m/2]，父结点1，**加起来应正好是m个关键字**）

   **此时若父结点关键字低于下限，要继续调整**

   

   



#### B+树（数据库）

##### 定义与性质（m阶B树）

+ 每个分支结点最多有m棵子树（同B树）
+ 非叶根结点至少两棵子树，其他分支结点至少有[m/2]棵子树（同B树）
+ **B+树的叶子结点指最下层的非空结点！！**（相当于B树的终端结点）
+ **B+树结点关键字个数和孩子个数相等**（B树孩子个数比关键字个数多一个）
+ **叶子结点包含全部关键字**（每个结点都含有上一层的关键字）
+ 叶结点中关键字从小到大排序，并且相邻叶结点按顺序链接起来



##### B树的查找

+ **查找的都是叶子结点**（每个叶子对应一个记录）
+ 可以用BST方式查找，**也可以顺序遍历叶子结点（叶子结点本身按顺序链接）**



##### B树和B+树区别

1. **B+树一个关键字对应一个子树**

2. B+树每个结点最多$m$个关键字，除根结点外最少$[m/2]$个关键字

   B树$[m/2]-1\le n \le m$

3. B+树叶子结点包含所有关键字

   B树关键字不重复

4. **B+树所有叶子结点仅仅是索引，最终都要靠叶子结点读取记录**

   非叶结点每个索引项只含有**对应子树的最大关键字**和指向该子树的指针

5. **B+树支持顺序查找和随机查找，B树仅支持随机查找**



##### B+树、B树与操作系统

+ B+树存放在**磁盘**中。

  查找为**分块查找**，每个叶子对应一个块，每查找一层叶子结点，都会将该块**读入内存**

+ B+树每个非叶结点不包含记录，因此可以用更少的空间存储；

  而B树每个结点都包含记录，存储花费更大

+ B+树分支数越多，树越矮，读磁盘次数更少，查找效率更快







### 4、散列查找

#### 性能分析

平均查找长度ASL用来度量散列表查找效率：成功、不成功

+ 不成功：查找的元素不在表里

**散列表的插入和查找是两个过程！！**

**ASL = 查找所有关键字的总比较次数/关键字个数**

**装填因子$\alpha = \frac{表中记录数n}{散列表长度m}$**

**平均查找长度ASL依赖于装填因子，不直接依赖于m和n**



##### 1. 线性探测法查找性能

可以证明，线性探测法的期望探测次数满足下列公式：

$p = \begin{cases} \frac{1}{2}\left[a+\frac{1}{(1-\alpha)^2}\right]，\quad （对于插入和不成功查找而言）\\ \frac{1}{2}\left(1 + \frac{1}{1-\alpha}\right)，\quad （对于成功查找而言）\end{cases}$



##### 2. 平方探测法和双散列探测法的查找性能

可以证明，平方探测法和双散列探测法探测次数满足下列公式：

$p = \begin{cases} \frac{1}{1-\alpha}，\quad （对于插入和不成功查找而言）\\ -\frac{1}{\alpha}\ln{(1-\alpha)}，\quad （对于成功查找而言）\end{cases}$



##### 插入与查找的区别

插入：

+ 冲突后，按照处理冲突的方法，找到空位置后，插入元素，即插入成功

查找：

+ 冲突后，按照处理冲突的方法，最后找到元素存放位置时，还要比较一次

  因此每个关键词的比较次数是**相对于插入的冲突次数+1**



##### 不成功的平均查找长度$ASL_u$

一般方法，将不在散列表中的关键字分成若干类（如根据H(key)值分类）

+ 对于每一类关键词，从H(key)开始，按照冲突处理方法，**直到找到一个空位置，此时才能判断此类元素不在表里**（空位置也算一次比较）
+ $ASL_u = 不在表中的每一类的查找次数和/类数$



#### 一些结论

+ **堆积问题**，是**同义词冲突的探查序列和非同义词之间不同的探查序列**交织在一起，

  导致关键字查询需要经过较长时间的探测距离，降低了散列的效率







## 六、排序

全部默认升序

### 1、简单排序

#### 选择排序

+ 每次从后面选出最小的换到前面来，枚举n-1次
+ **每趟排序可以确定一个元素的最终位置**

```C++
void selectionSort(vector<int>& a) {
    for(int i = 0; i < a.size(); i++) {
        int k = i;  // 存放最小元素下标
        for(int j = i + 1; j < a.size(); j++) {
            if(a[j] < a[k]) k = j;
        }
        swap(a[k], a[i]);   // 后面的最小元素换到i位置
    }
}
```

+ **不稳定**（存在交换）



#### 冒泡排序

```C++
void Bubble_Sort(vector<int>& a) {
    for(int i = 0; i < a.size(); i++) {
        bool flag = false;  // 记录本次排序是否有交换
        for(int j = a.size() - 1; j > i; j--) { // j倒着枚举
            if(a[j-1] > a[j]) {
                swap(a[j], a[j-1]);
                flag = true;
            }
        }
        if(!flag) return;   // 本次排序没有交换，说明数组已经有序
    }
}
```



+ 每次排序后最小的元素交换到每次排序元素的第一个位置，即**最终位置**，因此**每次排序都会形成一个有序的子序列**（类似Dijkstra)
+ `a[i]==a[j]`时不会交换，因此冒泡排序是一种**稳**定的排序算法
+ $O(n^2)$
+ **每趟排序前都会有已经有序长度为i-1的子序列**





#### 直接插入排序

+ 对于A[1]~A[n]，令i从2到n枚举，进行n-1趟操作

  假设某一趟时，序列前i-1个元素A[1]~A[i-1]已经有序，后面还未有序，

  则该趟**在[1,i-1]中寻找某一位置，使得A[i]插入该位置后(此时该位置后的元素全部后移)，A[1]~A[i]有序**

```C++
void insertSort(vector<int>& a, int n) {   // 插入排序，下标1~n;
    for(int i = 2; i <= n; i++) {   // a[i]是当前准备插入的元素
        int j = i;  // j从i往前遍历，找到插入位置
        int temp = a[i];    // 临时存放准备插入的元素
        for(; j > 1 && temp < a[j-1]; j--) {    // 只要前面的元素大
            a[j] = a[j-1];  // 就把前面元素后移
        }
        a[j] = temp;    // 插入
    }
}
```

+ 最好情况：已经有序，每趟只需比较一次且不用移动元素
+ 最坏情况：逆序，每趟比较i-1次，移动i-1次
+ 复杂度$O(n^2)$
+ 每趟开始前面的元素都有序，**但不是最终位置（可能会移动、甚至全部移动）**





#### 二分插入排序

由于每趟插入排序，前面i-1个元素是有序的，因此可以**二分得到a[i]的插入位置**

**为了保证排序算法的稳定性，应该用upper_bound(a[i])而不是lower_bound（相等的元素应先来后到）**

+ 将`upper_bound(a[i])`到a[i-1]的元素全部后移
+ 并将a[i]插入到`upper_bound(a[i])`的位置

```C++
int upper_bound(vector<int>& a, int x, int l, int r) {
    while(l < r) {  // l==r时找到位置
        int mid = l + (r-l)/2;
        if(a[mid] > x) r = mid; // 中间元素大于x，往左找（不排除此位置）
        else l = mid + 1; // 小于等于x，往右找
    }
    return l;   
}
void insertSort(vector<int>& a, int n) {    // 1~n
    for(int i = 2; i <= n; i++) {
        int temp = a[i];
        int j = upper_bound(a, a[i], 1, i);   // 二分区间[1, i]找插入位置j
        // 二分区间[1,i]可以使得a[i]比前面所有元素都大时应当返回i
        for(int k = i; k > j; k--) a[k] = a[k-1];   // 区间[j,i-1]元素全部后移至[j+1,i]
        a[j] = temp;    // 插入
    }
}
```

+ 元素移动次数不会改变





#### 希尔排序（插入排序优化）

+ 设置增量d，将原序列分割成若干子序列(**间隔为d的元素属于统一子序列，每个子序列长n/d，共有d个子序列**)，每个子序列进行插入排序

+ **缩小增量d，直至d=1**

+ **每缩小一次d，子序列长度都会增加**

  d=1时，子序列长度与原序列一样

```C++
void ShellSort(vector<int>& a, int n) {     // 1~n
    for(int d = n/2; d >= 1; d /= 2) {  // 枚举增量，由n/2每次减半
        // 对每个子序列进行插入排序
        for(int i = d + 1; i <= n; i++) {   // i从第一个子序列的第二个位置开始枚举，i++表示对下一个子序列排序
            // i为第i个子序列的第1个，i+d为第i个子序列的第二个
            int temp = a[i];
            int j = i;
            for(; j-d > 0 && a[j-d] > temp; j -= d) {   // 只要前面元素大
                a[j] = a[j-d];  // 前面元素后移
            }
            a[j] = temp;  // 插入
        }
    }
}
```

+ 上述代码每趟插入排序插入的元素数量不一样，插入一个后直接跳到下一个子序列操作，不断切换子序列

  **（i是顺序枚举，因此每增加了d都会回到最初的子序列，相当于子序列的下一个元素）**

```C++
void ShellSort(vector<int>& a, int n) {     // 1~n
    for(int d = n/2; d >= 1; d /= 2) {  // 枚举增量，由n/2每次减半
        // 对每个子序列进行插入排序
        for(int k = 1; k <= d; k++) {  // 共有d个子序列
            for(int i = d+k; i <= n; i += d) {    // i从每个子序列的第二个元素开始枚举，直到当前子序列的最后一个
                int temp = a[i];
                int j = i;
                for(; j-d > 0 && a[j-d] > temp; j -= d) {   // 只要前面元素大
                    a[j] = a[j-d];  // 就把前面元素后移
                }
                a[j] = temp;
            }
        }
    }
}
```

+ 这一代码每趟都将子序列完整的插入排序，i不是顺序枚举，而是在每段子序列中枚举



##### 希尔排序结论

+ **不稳定：**相等的元素分配到不同子序列，可能会改变相对次序

+ **只适合顺序存储**





### 2、归并排序

#### 二路归并

+ **O(nlogn)**
+ 分治的复杂度：O(logn)
+ 序列合并的复杂度：O(n)
+ **本质：将排序的任务转换为两个有序区间合并（从个数为1开始）。区间合并利用two-pointers思想，复杂度为O(n)**

```C++
// 将数组a的[L1, R1]和[L2, R2]区间合并为有序区间（此处L2 = R1 + 1）
void merge(int a[], int L1, int R1, int L2, int R2) {	// 归并
    int i = L1, j = L2;
    int tmp[maxn], index = 0;   // tmp数组存放合并后的序列
    while(i <= R1 && j <= R2) {
        if(a[i] <= a[j]) {
            tmp[index++] = a[i++];	// 为保证稳定性，遇到相同的元素优先选择前一个区间
        }else tmp[index++] = a[j++];
    }
    while(i <= R1) tmp[index++] = a[i++];	// 剩余的元素直接加入
    while(j <= R2) tmp[index++] = a[j++];
    for(int i = 0; i < index; i++) a[L1 + i] = tmp[i];  // 将合并后的序列赋值给a
}

void mergeSort(int a[]) {	// 归并排序（非递归）区间[1, n] 
    // step为组内元素个数，step/2为左子区间元素个数，等号可以不取
    for(int step = 2; step/2 <= n; step *= 2) {
        // 每step个元素一组，组内前step/2和后step/2个元组进行合并
        for(int i = 1; i <= n; i += step) {     // 对每一组
            int mid = i + step/2 - 1;   // 左子区间[i, mid]有严格step/2个元素（step/2一定是整数）
            if(mid + 1 <= n) {  // 此条件成立区间[mid+1, n]必有1个元素以上，即右子区间存在
                merge(a, i, mid, mid+1, min(mid + step/2, n));  // O(n)
            } 
            // 右子区间不存在说明已经排好序
        }
        // 此处可以输出归并排序某一趟结束后的序列
    }
}


void mergeSort(int a[], int l, int r) {   // 递归（闭区间[l, r]）
    if(l < r) {
        int mid = l + (r-l)/2;
        mergeSort(a, l, mid);       // 递归左区间
        mergeSort(a, mid+1, r);     // 递归右区间
        merge(a, l, mid, mid+1, r); // 最后归并
    }
}
```

+ merge操作需要长度为n的temp数组，因此空间复杂度为**$O(n)$**

+ 一共进行**$\log_2{N}趟$**



#### k路归并

+ k路归并就是一次把k个子序列合并为一个有序序列

+ k路归并的趟数m满足**$k^m = N$**，即**$m=\log_k{N}(向上取整)$**









#### 基数排序

+ 每个关键字拆分成多的元组，按层次顺序倒着排序**（权重递增）**

##### 例：三位数排序

+ 先按个位数排序，个位数相同的放在同一个链表（队列），再将链表收集起来
+ 再按十位数排序，是尾数相同的放在同一链表（**可以保证十位数相同的个位数一定有序）**，再收集
+ 接着按百位数排序，百位数相同的放在同一链表（**可以保证百位相同的十位和个位都已经有序）**
+ 最后按顺序链接所有链表（最后一次收集）

每次按位排序过程：从头到尾扫描每个关键字的当前位，添加到对应位的链表——$O(n)$



##### 性能分析

+ $O(d(n+r))$

  每个关键词分割成d位，即**d趟排序**；每次分配（按位排序）**$O(n)$**

  设每个关键词有**r种取值**，即r个链表，一趟收集**$O(r)$**（**不一定每位的取值个数一样，此处为了简化计算）**

+ **复杂度与序列初始状态无关**
+ **稳定**

##### 基数排序不是基于比较的排序算法！！





### 3、快排

##### 步骤：

1. 设k(==主元==)为a[0]，**将k挪动到适当位置，使得比k小的元素都在k左边，比k大的元素在k右边**。***这一步复杂度为O(n)***
2. 递归k左边的部分
3. 递归k右边的部分

```C++
void quickSort(int a[], int st, int ed) {   // 对数组a的区间[st, ed]快排
    if(st >= ed) return;    // 递归边界
    int k = a[st];  // 选主元（若主元是随机选取则需要将主元与a[st]交换位置）
    // 移动主元至适当位置
    int i = st, j = ed; //two-pointers	O(n)
    while(i != j) {     // i与j相遇时退出
        while(j > i && a[j] >= k) j--;   // 右边大，j左移
        swap(a[i], a[j]);
        while(i < j && a[i] <= k) i++;  // 左边小，i右移
        swap(a[i], a[j]);
    }//处理完后，a[i] = a[j] = k
    quickSort(a, st, i-1);  // 递归k的左边
    quickSort(a, i+1, ed);  // 递归k的右边
}
```

+ **快排效率与主元的选取有很大关系**

+ 元素已经基本有序时复杂度较高，速度最慢

+ 当每次选中的**主元都能将序列等分为两个子序列**时，速度最快

+ **快排的阶段性排序的特点是，第i趟完成时，会有*i个以上的数*出现在最终位置，即左边比它小，右边比它大**

+ 快排过程构成一个递归树，递归深度即树高。**主元每次都将子表等分时，树高$\log_2n$；**

  **对于已经排好序的序列，递归树退化成单链表，树高为n;**

##### 性能分析

+ 空间复杂度：**由于是递归，会用到递归工作栈，复杂度为树高（$O(log_2{n})\rarr O(n)$)**

+ 时间复杂度：**$O(n\log{n})\rarr O(n^2)$**



### 4、堆排序

#### 模板

```C++
int n;	// 最大堆元素个数
int heap[maxn];     // 最大堆，下标[1, n]

void downAdjust(int low, int high) {	// 每个结点只看子树
    int i = low, j = i*2;   // i为欲调整结点，j为其左孩子
    while(j <= high) {   // 左子树存在，就一直往下循环
        // 找到左右子树中较大结点的下标, 存放在j中
        if(j + 1 <= high && heap[j + 1] > heap[j]) { // 右子树存在&&右孩子>左孩子
            j = j + 1;
        }
        if(heap[j] > heap[i]) { // 子树较大结点比父结点大，交换
            swap(heap[j], heap[i]);
            i = j;      // 保持i为原来欲调整结点的下标
            j = i * 2;  // 左子树
        }else {     // 父结点比子结点大，不交换，并退出循环
            break;
        }
    }
}

void upAdjust(int low, int high) {
    int i = high, j = i/2;  // i为欲调整的结点，j为其父结点
    while(j >= low) {   // 父结点在规定范围内
        if(heap[j] < heap[i]) { // 父结点<子结点，交换
            swap(heap[j], heap[i]);
            i = j;      // 保持i为原来欲调整的结点
            j = i / 2;  // 父结点
        }else {
            break;
        }
    }
}

void createHeap() {		// 建堆
    for(int i = n/2; i >= 1; i--) { // 从第一个非叶子结点倒着向下调整
        downAdjust(i, n);
    }
}

void deleteTop() {      // 删除堆顶元素
    heap[1] = heap[n--];    // 最后一个元素覆盖堆顶，元素数量-1
    downAdjust(1, n);       // 并从堆顶向下调整
}

void insert(int x) {    // 向最大堆添加元素
    heap[++n] = x;      // 元素数量+1，在最后添加x
    upAdjust(1, n);     // 并从x处向上调整
}

void heapSort() {       // 堆排序（递增），排序结果存入原来堆数组
    createHeap();       // 建堆
    for(int i = n; i > 1; i--) {   	// 将堆顶调至最后-> 向下调整，重复操作，直到堆中只有一个元素
        swap(heap[1], heap[i]);		// 交换heap[i]与堆顶
        downAdjust(1, i-1);
    }
}
```



#### 性能分析

##### 复杂度$O(n\log n)$

+ **`createHeap()`:$O(n)$**

  从非叶子结点开始调整，**每个非叶结点最多只需比较两个孩子**

+ `downAdjust()`:$O(\log{n})$

  堆排序时每次从堆顶向下调整，须比较多个结点

  **`downAdjust`过程每个结点都要比较两次！！**

##### 稳定性：

+ **不稳定**
+ 相同元素不分父子



### 5、排序算法比较

##### 排序算法的稳定性：

地位相等的元素排序后先后位置不改变，称该算法是**稳定的**

+ 对于不稳定的排序算法，只需要举出一组关键字的实例，说明它的不稳定性即可



##### 内部排序和外部排序：

内部排序，指排序期间元素全部存放在内存中；

外部排序，指排序期间**元素无法全部同时存放在内存中，需要不断在内外移动**



##### 各种排序算法的性质

| 算法种类 | 时间复杂度（最好） | 平均        | 最坏       | 空间复杂度 | 是否稳定 |
| -------- | ------------------ | ----------- | ---------- | ---------- | -------- |
| 插入排序 | $O(n)$ | $O(n^2)$    | $O(n^2)$   |$O(1)$|是|
| 冒泡排序 | $O(n)$ | $O(n^2)$    |$O(n^2)$| $O(1)$ |是|
| 选择排序 | $O(n^2)$           | $O(n^2)$    | $O(n^2)$   | $O(1)$    | **否**   |
| 希尔排序 | 依赖于增量函数     |             |            | $O(1)$    | 否       |
| 快排     | $O(nlogn)$         | $O(nlogn)$  | $O(n^2)$   | $O(logn)$ | 否       |
| 堆排序   | $O(nlogn)$         | $O(nlogn)$  | $O(nlogn)$ | $O(1)$    | 否       |
| 归并排序 | $O(nlogn)$         | $O(nlogn)$  | $O(nlogn)$ | $O(n)$     | 是       |
| 基数排序 | $O(d(n+r))$        | $O(d(n+r))$ | $O(d(n+r)$ | $O(r)$     | 是       |





##### 比较次数与初始序列状态无关:

+ 选择排序：永远是$\frac{n(n-1)}{2}$次
+ 归并排序：比较只在`merge`中执行，**`merge`次数为$\log_2 n$**



##### 排序趟数与初始序列状态无关

+ 插入排序 (n-1)
+ 选择排序 (n-1)
+ 基数排序 (d)
+ 归并排序 ($\log_2n$)
+ 堆排序 (n-1)
+ 快排（n）：每趟排序确定一个元素的最终位置



##### 移动次数与初始排列次序无关：

+ 基数排序
+ **假设初始已经有序+排除法**



### 6、外部排序

#### 概念

##### 外部排序：

+ 数据元素太多，无法一次全部读入内存
+ 排序过程中需要多次进行内存外存之间的交换

##### 通常采用归并排序法

















### 7、一些结论

+ 对于任意n个关键字排序的**比较次数至少为$\log_2(n!)$(向上取整)**
+ 待排序元素序列基本有序时，效率最高的排序方法是**直接插入排序**

+ 多层排序时，**若存在不稳定的排序方法，应先倒着从最后一层开始，不稳定的算法先用，最后再排第一层(权重递增顺序）**

  **不稳定的算法不能放到最后！！（类似个十百位的基数排序）**

+ 归并排序空间复杂度最高，永远是**$O(n)$**；快排空间复杂度为**$O(\log_2n)\rarr O(n)$**









## 七、kmp



