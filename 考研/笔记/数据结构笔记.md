数据结构笔记by以禾

****

## 一、线性表

### 链表

#### 单链表

##### 链表的插入：

+ 需要知道插入位置的前驱结点（**从表头顺序遍历**）
+ 先修改要插入的结点的指针
+ 再修改前驱结点的指针

##### 链表的删除：

+ 要知道删除结点的前驱结点（**从表头顺序遍历**）
+ 只需要修改前驱结点的指针
+ 最后delete/free

**已知一个结点，只能对后继结点进行操作（插入/删除）**



#### 双链表

##### 插入和删除

+ 操作与单链表类似，但需要多操作两个指针

**双链表有前驱指针，因此可以还对已知的当前结点进行插入删除操作**

+ 双链表+尾指针：在尾部结点操作不需要遍历



#### 循环链表

循环链表在任何位置插入和删除都是等价的，无需判断是否在表尾。即**循环链表有头指针等价于有尾指针**。

循环链表尾指针是头指针的前驱



****

## 二、栈、队列和数组

### 栈

#### 顺序栈

**卡特兰（Catalan）数**：n个不同元素进栈，出栈不同排列的个数为$\frac{1}{n+1}C^n_{2n}$

##### 共享栈

+ 栈满条件：**两个栈顶指针相邻**（`top2-top1==1`）
+ 好处：节省存储空间，降低发生上溢的可能
+ 对存取时间无影响

#### 链栈

##### 注意点

+ 单链表实现

+ **所有操作在表头进行**，即next指向栈底方向
+ top是一个指针（不是结点），指向栈顶（链表第一个结点）。

##### 操作

1. 向栈顶指针为top插入结点x

```C++
x->next = top;	// 先修改要插入的结点指针
top = x;		// 保持top指向栈顶
```

2. Pop操作，x存放出栈元素

```C++
x = top->data;	// 获得栈顶元素
top = top->next;	// 修改top指针（指向下一个结点）
```



### 队列

#### 顺序存储

+ 初始化（队空条件）：`Q.front == Q.rear == 0 `

+ 进队时队尾指针向后移动，出队时队首指针向后移动，因此可能会出现两个指针挤在数组末尾，造成**上溢**，

  这种溢出不是真正的溢出，数组中还有存放空间，因此成为**“假溢出”**

+ **队尾入队，队头出队**

#### 循环队列

+ 解决了假溢出的弊端
+ 初始化（队空条件）：`Q.front == Q.rear == 0`
+ 队首指针进1：`Q.front = (Q.front + 1) % MaxSize`
+ 队尾指针进1：`Q.rear = (Q.rear + 1) % MaxSize `
+ **队列长度**：`(Q.rear + MaxSize - Q.front) % MaxSize`
+ 出队或入队指针都按顺时针方向进1

##### 判断队满

1. 牺牲一个单元：

   **队头指针在队尾指针的下一个位置作为队满的标志**，即`(Q.rear + 1) % MaxSize == Q.front`

2. 增加元素个数的数据成员：

   `Q.size == MaxSize`时队满，此时`Q.front == Q.rear`

3. 增设tag成员：

   tag==0时：若因删除导致`Q.front == Q.rear`, 为队空

   tag==1时; 若因插入导致`Q.front == Q.rear`, 为队满



#### 链式队列

+ 判空：`Q.front == NULL && Q.rear == NULL`
+ 初始化两个指针都指向头结点
+ **front始终指向头结点，rear始终指向最后一个结点**



#### 双端队列

+ 两边都能入队出队
+ 输出受限：有一端只能进
+ 输入受限：有一端只能出





## 三、树

### 基本概念

#### 树

+ 结点的度数为结点的孩子个数
+ 树的结点数等于所有结点的度数和+1
+ 树根为第1层
+ 树的深度自顶向下，高度自底向上
+ 度为m的树（m>1)表示树高>1
+ 度为m的树第i层最多有$m^{i-1}$个结点
+ 高为h的m叉树至多有$\sum^{h-1}_{i=0}{m^i} = \frac{m^h-1}{m-1}$



#### 二叉树

+ 二叉树 n0 = n2 + 1
+ 第 i 层最多$2^{i-1}$个结点
+ h层的二叉树最多有$2^{i}-1$个结点
+ 二叉树结点个数为偶数，则n1必为奇数(n1 = n - 2n2 - 1)

+ **完全二叉树n1只能取0或1**
+ 完全二叉树有n个结点，则最后一个有孩子的结点下标为[n/2],其余全是叶子



### 二叉树遍历

#### 非递归遍历

##### 中序

1. 沿着根的左孩子，依次入栈，直到左孩子为空，说明找到了可以输出的结点。
2. 栈顶元素出栈并访问：若右孩子为空，继续执行2；否则对右子树执行1

```C++
vector<int> path;
void inOrder(node* root) {      // 非递归中序
    stack<node*> stk;
    node* p = root;     // p为遍历指针
    while(!stk.empty() || p) {  // p空且栈空时退出
        if(p) { // 一路向左遍历并入栈
            stk.push(p);
            p = p->lchild;
        }else { // 当前结点为空，则应该访问栈顶元素（当前的父结点），再遍历父结点的右子树
            p = stk.top();
            stk.pop();
            path.push_back(p->data);
            p = p->rchild;
        }
    }
}
```



##### 先序

```C++
vector<int> path;
void preOrder(node* root) {     // 非递归先序
    stack<node*> stk;
    node* p = root;     // p为遍历指针
    while(!stk.empty() || p) {  // p空且栈空时退出
        if(p) { // 一路向左遍历
            path.push_back(p->data);    // 先访问（当前子树的根结点）
            stk.push(p);          // 再入栈
            p = p->lchild;  // 继续向左
        }else { // 当前结点为空，则回头遍历栈顶结点的右子树
            p = stk.top();  // 栈顶结点为当前结点的父结点
            stk.pop();
            p = p->rchild;  // 遍历右子树
        }
    }
}
```



#### 一些结论

+ 先序和后序正好相反$\Lrarr$高度等于结点数$\Lrarr$只有一个叶子
+ 两个结点前序为XY，后序为YX，则X是Y的祖先

### 线索二叉树

+ 若无左子树，则`lchild`指向前驱结点；若无右子树，则`rchild`指向后继结点
+ 增加两个标志位`ltag`和`rtag`，为0表示由左(右)子树
+ **二叉树的线索化**：将二叉链表的空指针**改为**指向前驱或后驱的线索
+ **线索二叉树是加上线索后的链表结构，是一种物理结构**
+ **无法通过线索直接找到的**：先序前驱，后序后继（**需要知道双亲结点，而线索二叉树没有存放双亲的指针）





### 树和森林

#### 树、森林与二叉树的转换

##### 树转二叉树

+ ”孩子兄弟表示法“：**左孩子右兄弟**



##### 二叉树转森林

1. 将根及左子树视为第一棵树，右链断开
2. 剩下来的二叉树按同样方法
3. 直到最后**只剩一棵没有右子树的二叉树**为止



#### 树和森林的遍历

**相当于转换为二叉树后再遍历**



##### 树先序：

1. 访问根结点
2. 依次遍历根结点的每棵子树（先根后子树）

##### 树后序：

1. 依次遍历根结点的每棵子树
2. 访问根结点
3. **相当于转换为二叉树后的中序遍历**

##### 森林先序（递归定义）：

1. 访问第一棵树的根
2. 先序遍历第一棵树根的子树森林
3. 同样方法遍历剩下的森林

##### 森林中序（递归定义）：

1. 中序遍历第一棵树根的子树森林
2. 访问第一棵树根
3. 同样方法遍历剩下的森林



##### 与二叉树遍历的对应

| 树   | 森林 | 二叉树 |
| ---- | ---- | ------ |
| 先序 | 先序 | 先序   |
| 后序 | 中序 | 中序   |



#### 一些结论

+ 森林转二叉树后，由二叉树判断树的个数：**只要数右上方的结点数**
+ **一棵树也可叫森林！！**
+ 森林由n个非叶结点，转换为二叉树后会出现**n个叶子**，加上在最后一棵树的根结点，共有**n+1**个无右子树的结点
+ 森林叶子个数等于转为二叉树后无左孩子的结点个数
+ 森林树的个数等于**结点数减边数**（连通分支数）



### 哈夫曼树与并查集

#### 结论

+ n个叶子的哈夫曼树有n-1个非叶结点
+ 结点的带权路径长度是**由根到结点经过的边数**乘该结点权值；树的带权路径长度是**所有叶结点**带权路径长度之和
+ **哈夫曼树只有度为0和2的结点**
+ 并查集是**双亲表示法**存储的树



## 四、图

### 1、基本概念

#### 说法

+ **图至少有一个顶点，可以没有边**

+ **极大连通分量：子图顶点可以少，边不能少**
+ **极小连通子图：保证子图连通，且边最少**
+ **连通图的生成树是包含图中全部顶点的一个极小连通子图**

+ 简单路径：顶点不重复出现的路径
+ 简单回路：除了第一个和最后一个顶点相同外，其余顶点不重复的路径

#### 无向图

+ **所有顶点度数和等于边数的两倍**（每条边关联两个顶点）

+ 完全图：$\frac{n(n-1)}{2}$条边（每个点的度为n-1）

+ 无向图的**极大连通分量称为连通子图**

+ 边数$<n$，一定是非连通图

+ **非连通图最多$\frac{(n-1)(n-2)}{2} +1$条边**（n-1个顶点的完全图+一个孤立顶点）



#### 有向图

+ **所有顶点的入度和=所有顶点出度和=边数**（每条有向边都有一个起点和终点）
+ 有向完全图：$n(n-1)$条边（每个顶点出度和入度均为n-1)
+ **有向图讨论强连通，无向图讨论连通**
+ **强连通图最少n条边**（形成一个环）



### 2、图的存储

#### 邻接矩阵

+ 对于无向图，每行或每列非零元素的个数为对应顶点的度
+ 对于有向图，每行为顶点的出度，每列为顶点的入度
+ 邻接矩阵为A, $A^n$的元素$A^n[i][j$为$i到j长度为n的路径数目$

#### 邻接表

+ 无向图邻接表每条边存放两次（即边表个数一定是偶数）



### 3、图的遍历

#### 1.DFS

+ 空间复杂度$O(n)$
+ 时间复杂度：邻接矩阵$O(n^2)$，邻接表$O(n+e)$
+ **DFS遍历DAG，退出递归时输出顶点，最后得到的序列是逆拓扑有序序列**

##### DFS生成树

+ DFS序列对应该生成树的先序遍历
+ 显然不唯一
+ **树高可长可短**



#### 2.BFS

+ 空间复杂度$O(n)$
+ 时间复杂度：邻接矩阵$O(n^2)$，邻接表$O(n+e)$

##### BFS生成树

+ 每个结点的层序构造的一棵树
+ BFS序列对应该生成树的层序遍历
+ 生成树不唯一，但**树高唯一，是该图所有生成树中树高最短的（树根到其他结点的路径都是最短的）**
+ **BFS生成树高度$\le$DFS生成树高度**





### 4、最短路

#### Dijkstra

+ **每次循环选中的顶点一定是当前距顶点最短的一个**，即顺序是d数组的递增序列



### 5、最小生成树

**含有图中所有顶点，且边权值和最小**

#### 1.Prim

与Dijkstra思想几乎相同

##### 与Dijkstra区别：

+ Dijkstra找到未访问的最短距离的点后，优化从该点可以到达且能使其与起点距离更短的点（**`d[i]`表示i与起点的最短距离**）
+ Prim找到不在生成树的最短距离的点后，优化从该点可以到达且能使其与生成树中任意一点距离更短的点（**`d[i]`表示i与生成树的最短距离**）
+ **被优化的结点不算已访问**，每次循环只记录一个已访问（即与生成树最短的一个结点）

##### 和Dijkstra复杂度都是$O(n^2)$

#### 2.Kruskal

边集数组+并查集

算法：

1. 对所有边按边权排序
2. 对于每条边，测试两端点是否在同一集合中，若不在
   1. 合并两条边
   2. `ans += 当前边权`
   3. 最小生成树当前边数++
   4. **当边数等于顶点数-1时退出循环**

**复杂度$O(mlogm)$**



### 6、关键路径（即DAG最长路）

**AOV（Activity On Vertex）**：用顶点表示活动，有向边边表示优先级

**AOE(Activity On Edge）**：边表示活动，边权表示活动进行的时间，顶点表示活动完成的事件

**AOE网中的最长路径称为关键路径，关键路径上的活动称为关键活动**



#### 1. 拓扑排序（DAG)

##### 算法：

队列+入度数组

1. 将所有入度为0的顶点入队
2. 循环（队列为空退出）：
   1. 取队首，对于从它出发的所有边，将其邻接点入度-1
   2. 邻接点入度为0时入队
3. **判断是否是DAG**：队列为空时**入过队的结点数为n**，则是DAG，否则不是

**用邻接表存储，复杂度$O(n+m)$**

#### 2.关键路径的四个参量

​			$事件v_i ---活动a_r --\rarr事件v_j$

##### 1. 事件$v_k$（顶点）的最早发生时间(ve)

+ 指从源点$v$到$v_k$的最长路径长度
+ $v_k$的最早发生时间决定了从$v_k$开始的活动（边）能开工的最早时间

+ $ve[源点]=0$

+ 从前往后算（**拓扑序**）：（对于每个点，可以计算所有后继节点的ve）

  $ve[j] = max\{ve[i_1] + length[r_1], \\ \quad ve[i_2] + length[r_2],\\...,\\ \quad ve[i_k]+length[r_k]\}$

  **结点j的ve是所有前驱结点的最长时间**

+ 拓扑排序时可以顺便完成ve的计算

  

##### 2. 事件的最迟发生时间(vl)

+ 要保证后继结点在其最迟发生事件能完成

+ $vl[汇点] = ve[汇点]$

+ 从后往前算（**逆拓扑序**）：

  $vl[i] = min\{vl[j_1]-length[r_1], \\ \quad vl[j_2]-length[r_2],\\ ..., \\ \quad vl[j_k]-length[r_k\}$

+ 拓扑排序序列用站存放，则可以依次出栈来用所有后继结点计算栈顶结点的vl



##### 3. 活动$a_r$（边）的最早开始时间(e)

+ 即这条边的起点（事件）的最早发生时间
+ `e[r] = ve[i]`

##### 4. 活动的最迟开始时间(l)

+ 即这条边的终点（事件）的最迟发生时间-当前活动的耗时
+ `l[r] = vl[j] - length[r]`



#### 4.关键路径

+ **最早开始时间==最迟开始时间的活动**是关键活动`e[r]==l[r]`

##### 求关键路径的步骤

1. 从源点开始，计算所有结点的ve
2. 从汇点回头，计算所有结点的vl
3. 求各边（活动）的e和l
4. 找到e==l的关键活动



### 七、重要结论

1. **拓扑序列唯一并不能唯一确定该图**
2. **有序拓扑序列的图的邻接矩阵是三角矩阵**（有序是人为的）
3. **只有缩短才会导致出现不同的关键路径**（缩短的不是所有关键路径上的公共边）
4. **DAG最长路一定是关键路径**，因此画好图后直接找最长路即可





## 五、查找





## 六、排序





## 七、kmp



